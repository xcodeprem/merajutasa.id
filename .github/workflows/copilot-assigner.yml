name: Copilot Sub-issue Assigner

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:
    inputs:
      start_from:
        description: 'Resume from this issue number (strict order from here)'
        required: false
        type: string
      reset_earlier:
        description: 'If true, remove in-progress label from earlier items before resuming'
        required: false
        type: boolean
        default: false
      force_issue:
        description: 'Force assignment of this single issue (bypass order) - emergency only'
        required: false
        type: string
      verbose:
        description: 'Set to true for per-issue debug logging'
        required: false
        type: boolean
        default: false

concurrency:
  group: copilot-assigner-singleton
  cancel-in-progress: false

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  assign-next:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332

      - name: Show gh version (preinstalled)
        run: gh --version

      - name: Read config
        id: cfg
        run: |
          cat .github/copilot-orchestrator.json
          echo "ASSIGNEE=$(jq -r '.assignee' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "LABEL_INPROG=$(jq -r '.labels.inProgress' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "LABEL_DONE=$(jq -r '.labels.done' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "SEQ_MODE=$(jq -r '.sequence.mode // ""' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "EPIC_NUM=$(jq -r '.sequence.epic // ""' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "ORDER=$(jq -c '.sequence.order // []' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "STRICT=$(jq -r '.sequence.strict // "false"' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "FALLBACK_ON_NONE=$(jq -r '.sequence.fallbackOnNone // "false"' .github/copilot-orchestrator.json)" >> $GITHUB_OUTPUT
          echo "START_FROM=${{ github.event.inputs.start_from || '' }}" >> $GITHUB_OUTPUT
          echo "RESET_EARLIER=${{ github.event.inputs.reset_earlier || 'false' }}" >> $GITHUB_OUTPUT
          echo "FORCE_ISSUE=${{ github.event.inputs.force_issue || '' }}" >> $GITHUB_OUTPUT
          echo "VERBOSE=${{ github.event.inputs.verbose || 'false' }}" >> $GITHUB_OUTPUT

      - name: Ensure core labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          gh label create '${{ steps.cfg.outputs.LABEL_INPROG }}' --repo "$GITHUB_REPOSITORY" --color 1f6feb --description "Being worked by Copilot" 2>/dev/null || true
          gh label create '${{ steps.cfg.outputs.LABEL_DONE }}' --repo "$GITHUB_REPOSITORY" --color 2ea043 --description "Completed by Copilot" 2>/dev/null || true

      - name: Find in-progress issues (scoped to order/epic if configured)
        id: inprog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ steps.cfg.outputs.SEQ_MODE }}" = "explicit" ] && [ "${{ steps.cfg.outputs.ORDER }}" != "[]" ]; then
            printf "%s" '${{ steps.cfg.outputs.ORDER }}' | jq -r '.[]' > order.txt
            if [ -n "${{ steps.cfg.outputs.START_FROM }}" ]; then
              awk -v s="${{ steps.cfg.outputs.START_FROM }}" '{if(found||$0==s){print; found=1}}' order.txt > order.sliced.txt || true
              mv order.sliced.txt order.txt
            fi
            gh issue list --repo "$GITHUB_REPOSITORY" --label "${{ steps.cfg.outputs.LABEL_INPROG }}" --state open --json number | jq -r '.[].number' > inprog_all.txt
            COUNT=$(grep -Fx -f order.txt inprog_all.txt | wc -l | tr -d '[:space:]')
            echo "COUNT=$COUNT" >> $GITHUB_OUTPUT
          elif [ "${{ steps.cfg.outputs.SEQ_MODE }}" = "epic-body" ] && [ -n "${{ steps.cfg.outputs.EPIC_NUM }}" ]; then
            # Build the ordered list of issue numbers from the epic body
            gh api repos/${GITHUB_REPOSITORY}/issues/${{ steps.cfg.outputs.EPIC_NUM }} --jq '.body' > epic.md
            awk 'match($0, /#([0-9]+)/, m){print m[1]}' epic.md | awk '!seen[$0]++' > order.txt || true
            if [ -n "${{ steps.cfg.outputs.START_FROM }}" ]; then
              awk -v s="${{ steps.cfg.outputs.START_FROM }}" '{if(found||$0==s){print; found=1}}' order.txt > order.sliced.txt || true
              mv order.sliced.txt order.txt
            fi
            gh issue list --repo "$GITHUB_REPOSITORY" --label "${{ steps.cfg.outputs.LABEL_INPROG }}" --state open --json number | jq -r '.[].number' > inprog_all.txt
            COUNT=$(grep -Fx -f order.txt inprog_all.txt | wc -l | tr -d '[:space:]')
            echo "COUNT=$COUNT" >> $GITHUB_OUTPUT
          else
            gh issue list --repo "$GITHUB_REPOSITORY" --label "${{ steps.cfg.outputs.LABEL_INPROG }}" --state open --json number | tee inprog.json
            echo "COUNT=$(jq 'length' inprog.json)" >> $GITHUB_OUTPUT
          fi

      - name: Optional reset earlier in-progress labels
        if: ${{ steps.cfg.outputs.SEQ_MODE == 'explicit' && steps.cfg.outputs.RESET_EARLIER == 'true' && steps.cfg.outputs.ORDER != '[]' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          printf "%s" '${{ steps.cfg.outputs.ORDER }}' | jq -r '.[]' > order.txt
          if [ -n "${{ steps.cfg.outputs.START_FROM }}" ]; then
            awk -v s="${{ steps.cfg.outputs.START_FROM }}" '{if(!found && $0!=s){print} if($0==s){found=1}}' order.txt > earlier.txt || true
          else
            : > earlier.txt
          fi
          while read n; do
            [ -z "$n" ] && continue
            gh issue edit "$n" --repo "$GITHUB_REPOSITORY" --remove-label '${{ steps.cfg.outputs.LABEL_INPROG }}' || true
          done < earlier.txt

      - name: Determine next issue
        id: next
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          VERBOSE='${{ steps.cfg.outputs.VERBOSE }}'
          force='${{ steps.cfg.outputs.FORCE_ISSUE }}'
          if [ -n "$force" ]; then
            echo "NUM=$force" >> $GITHUB_OUTPUT
            echo "GATE=" >> $GITHUB_OUTPUT
            echo "Forced issue selection: #$force"
            exit 0
          fi

          choose_from_order() {
            : > next.json
            GATE=""
            while read n; do
              [ -z "$n" ] && continue
              gh issue view "$n" --repo "$GITHUB_REPOSITORY" --json number,state,isPullRequest,labels > cand_full.json 2>/dev/null || true
              if [ ! -s cand_full.json ]; then
                [ "$VERBOSE" = "true" ] && echo "[skip #$n] fetch-failed"
                continue
              fi
              IS_PR=$(jq -r '.isPullRequest' cand_full.json)
              STATE=$(jq -r '.state' cand_full.json)
              HAS_INPROG=$(jq -r '.labels|map(.name)|index("'"${{ steps.cfg.outputs.LABEL_INPROG }}"'")' cand_full.json)
              HAS_DONE=$(jq -r '.labels|map(.name)|index("'"${{ steps.cfg.outputs.LABEL_DONE }}"'")' cand_full.json)
              HAS_BLOCKED=$(jq -r '.labels|map(.name)|index("copilot:blocked")' cand_full.json)
              if [ "$IS_PR" = "true" ] || [ "$STATE" != "OPEN" ]; then
                [ "$VERBOSE" = "true" ] && echo "[skip #$n] not-open-or-pr state=$STATE isPR=$IS_PR"
                continue
              fi
              if [ "$HAS_INPROG" != "null" ]; then
                [ "$VERBOSE" = "true" ] && echo "[gate #$n] already in-progress"
                GATE="$n"
                break
              fi
              if [ "$HAS_DONE" = "null" ] && [ "$HAS_BLOCKED" = "null" ]; then
                jq '{number}' cand_full.json > next.json
                [ "$VERBOSE" = "true" ] && echo "[select #$n] eligible (no done/blocked/in-progress)"
                break
              else
                [ "$VERBOSE" = "true" ] && echo "[skip #$n] done_or_blocked done=$HAS_DONE blocked=$HAS_BLOCKED"
              fi
            done < order.txt
            NUM=$(jq -r '.number // ""' next.json 2>/dev/null || echo "")
            echo "NUM=$NUM" >> $GITHUB_OUTPUT
            echo "GATE=$GATE" >> $GITHUB_OUTPUT
            echo "Selected issue: ${NUM:-<none>}  Gate: ${GATE:-<none>}"
          }

          if [ "${{ steps.cfg.outputs.SEQ_MODE }}" = "explicit" ] && [ '${{ steps.cfg.outputs.ORDER }}' != "[]" ]; then
            printf "%s" '${{ steps.cfg.outputs.ORDER }}' | jq -r '.[]' > order.txt
            if [ -n "${{ steps.cfg.outputs.START_FROM }}" ]; then
              awk -v s="${{ steps.cfg.outputs.START_FROM }}" '{if(found||$0==s){print;found=1}}' order.txt > order.slice && mv order.slice order.txt
            fi
            choose_from_order
            # If nothing selected and no gate and not already verbose, re-run with verbose to print reasons
            if [ -z "${NUM:-}" ] && [ -z "${GATE:-}" ] && [ "$VERBOSE" != "true" ]; then
              echo "No candidate found silently; re-running diagnostics with verbose=true"
              VERBOSE=true
              choose_from_order
            fi
            if [ -z "${NUM:-}" ] && [ -z "${GATE:-}" ] && [ "${{ steps.cfg.outputs.STRICT }}" = "true" ] && [ "${{ steps.cfg.outputs.FALLBACK_ON_NONE }}" = "true" ]; then
              echo "No eligible issue in ordered list (all done/blocked/closed). (Fallback enabled) Searching any open issue without in-progress/done/blocked..."
              gh issue list --repo "$GITHUB_REPOSITORY" --state open --json number,labels \
                | jq '[.[]
                    | select((.labels|map(.name)|index("'"${{ steps.cfg.outputs.LABEL_INPROG }}"'"))|not)
                    | select((.labels|map(.name)|index("'"${{ steps.cfg.outputs.LABEL_DONE }}"'"))|not)
                    | select((.labels|map(.name)|index("copilot:blocked"))|not)
                  ] | sort_by(.number) | .[0] // {}' > fallback.json
              FNUM=$(jq -r '.number // ""' fallback.json)
              if [ -n "$FNUM" ]; then
                echo "NUM=$FNUM" >> $GITHUB_OUTPUT
                echo "Selected issue via fallback: $FNUM"
              else
                echo "No fallback candidate either."
              fi
            fi
          elif [ "${{ steps.cfg.outputs.SEQ_MODE }}" = "epic-body" ] && [ -n "${{ steps.cfg.outputs.EPIC_NUM }}" ]; then
            gh api repos/${GITHUB_REPOSITORY}/issues/${{ steps.cfg.outputs.EPIC_NUM }} --jq '.body' > epic.md
            awk 'match($0,/#[0-9]+/,m){gsub("#","",m[0]);print m[0]}' epic.md | awk '!seen[$0]++' > order.txt || true
            if [ -n "${{ steps.cfg.outputs.START_FROM }}" ]; then
              awk -v s="${{ steps.cfg.outputs.START_FROM }}" '{if(found||$0==s){print;found=1}}' order.txt > order.slice && mv order.slice order.txt
            fi
            choose_from_order
          else
            echo "Default numeric scan (no explicit/epic sequence configured)."
            gh issue list --repo "$GITHUB_REPOSITORY" --state open --json number,title,labels \
              | jq '[.[]
                  | select((.labels|map(.name)|index("'"${{ steps.cfg.outputs.LABEL_INPROG }}"'"))|not)
                  | select((.labels|map(.name)|index("'"${{ steps.cfg.outputs.LABEL_DONE }}"'"))|not)
                  | select((.labels|map(.name)|index("copilot:blocked"))|not)
                ] | sort_by(.number) | .[0] // {}' > next.json
            NUM=$(jq -r '.number // ""' next.json)
            echo "NUM=$NUM" >> $GITHUB_OUTPUT
            echo "GATE=" >> $GITHUB_OUTPUT
            echo "Selected issue: ${NUM:-<none>}"
          fi

      - name: Exit if earlier item already in progress (strict)
        if: ${{ steps.cfg.outputs.SEQ_MODE == 'explicit' && steps.cfg.outputs.STRICT == 'true' && steps.next.outputs.GATE != '' }}
        run: echo "Earlier issue #${{ steps.next.outputs.GATE }} already in progress; strict order hold."

      - name: Abort if none selected
        if: ${{ steps.next.outputs.NUM == '' }}
        run: |
          echo "No eligible issue selected. Reasons could be:"
          echo " - All remaining issues are done / blocked / closed"
          echo " - You intended to skip done ones: use workflow_dispatch input start_from"
          echo " - Or force selection via force_issue input"
          exit 0

      - name: Assign to Copilot and mark in-progress
        if: ${{ steps.next.outputs.NUM != '' && steps.next.outputs.GATE == '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          n='${{ steps.next.outputs.NUM }}'
          echo "Operating on $GITHUB_REPOSITORY #$n"
          gh issue edit "$n" --repo "$GITHUB_REPOSITORY" --add-assignee '${{ steps.cfg.outputs.ASSIGNEE }}' || echo "Assignee add failed (maybe already assigned)."
          gh issue edit "$n" --repo "$GITHUB_REPOSITORY" --add-label '${{ steps.cfg.outputs.LABEL_INPROG }}'
          gh issue comment "$n" --repo "$GITHUB_REPOSITORY" --body "AI run started: marking as in-progress (automated orchestrator)."
          echo "Assigned issue #$n."
