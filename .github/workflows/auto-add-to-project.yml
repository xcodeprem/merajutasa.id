name: Auto-add to Project

on:
  issues:
    types: [opened, labeled, unlabeled, reopened, edited, closed]
  pull_request:
    types: [opened, labeled, unlabeled, reopened, edited, closed, synchronize]
  issue_comment:
    types: [created]

jobs:
  add-to-project:
    runs-on: ubuntu-latest
    steps:
      - name: Add item and set fields
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }} # Classic PAT
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN }}
          script: |
            if (context.eventName === 'issue_comment') {
              const comment = context.payload.comment.body.trim().toLowerCase();
              if (!comment.includes('+project')) { console.log('No +project'); return; }
              console.log('Trigger via +project');
            }
            const ownerLogin = process.env.PROJECT_OWNER || '${{ vars.PROJECT_OWNER }}' || 'Andhika-Rey';
            const projectTitle = process.env.PROJECT_TITLE || '${{ vars.PROJECT_TITLE }}' || 'MerajutASA Program Board';

            // Project lookup (fields via interface fragment)
            let project;
            try {
              const q = `
                query($owner: String!) {
                  repositoryOwner(login: $owner) {
                    ... on User {
                      projectsV2(first: 50) {
                        nodes {
                          id title
                          fields(first: 50) {
                            nodes {
                              __typename
                              ... on ProjectV2FieldCommon { id name dataType }
                              ... on ProjectV2SingleSelectField { options { id name } }
                            }
                          }
                          items(first: 100) {
                            nodes { id content { ... on Issue { id number } ... on PullRequest { id number } } }
                          }
                        }
                      }
                    }
                    ... on Organization {
                      projectsV2(first: 50) {
                        nodes {
                          id title
                          fields(first: 50) {
                            nodes {
                              __typename
                              ... on ProjectV2FieldCommon { id name dataType }
                              ... on ProjectV2SingleSelectField { options { id name } }
                            }
                          }
                          items(first: 100) {
                            nodes { id content { ... on Issue { id number } ... on PullRequest { id number } } }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              const resp = await github.graphql(q, { owner: ownerLogin });
              const nodes = resp.repositoryOwner?.projectsV2?.nodes || [];
              project = nodes.find(p => p.title === projectTitle);
            } catch (e) {
              core.warning(`Project lookup failed: ${e.message}`);
              return;
            }
            if (!project) { console.log(`Project "${projectTitle}" not found`); return; }

            const projectId = project.id;
            const fields = project.fields.nodes;
            const existingItems = project.items.nodes;

            // Derive repo owner/name and number consistently across events
            const repoOwner = context.payload.repository?.owner?.login || process.env.GITHUB_REPOSITORY.split('/')[0];
            const repoName = context.payload.repository?.name || process.env.GITHUB_REPOSITORY.split('/')[1];
            let isPRContext = false;
            let number = undefined;
            if (context.eventName === 'pull_request') {
              isPRContext = true; number = context.payload.pull_request.number;
            } else if (context.eventName === 'issues') {
              isPRContext = false; number = context.payload.issue.number;
            } else if (context.eventName === 'issue_comment') {
              isPRContext = !!context.payload.issue?.pull_request; // PRs are issues with pull_request link
              number = context.payload.issue?.number;
            } else {
              // Fallback: treat as issue
              isPRContext = false; number = context.payload.issue?.number || context.payload.pull_request?.number;
            }
            if (!number) { console.log('No issue/PR number detected; exiting'); return; }

            // Build a query that asks ONLY for the relevant node to avoid GraphQL errors
            const contentQuery = isPRContext
              ? `query($owner:String!, $repo:String!, $number:Int!) {
                   repository(owner:$owner, name:$repo) {
                     pullRequest(number:$number) {
                       id number title body merged
                       labels(first:50){ nodes { name } }
                       milestone { title dueOn }
                       assignees(first:10){nodes{login}}
                     }
                   }
                 }`
              : `query($owner:String!, $repo:String!, $number:Int!) {
                   repository(owner:$owner, name:$repo) {
                     issue(number:$number) {
                       id number title body
                       labels(first:50){ nodes { name } }
                       milestone { title dueOn }
                       assignees(first:10){nodes{login}}
                     }
                   }
                 }`;
            const contentResp = await github.graphql(contentQuery, { owner: repoOwner, repo: repoName, number });
            const content = isPRContext ? contentResp.repository.pullRequest : contentResp.repository.issue;
            if (!content) { console.log(`Content not found for #${number}`); return; }
            const contentId = content.id;
            const labels = new Set((content.labels?.nodes || []).map(l => l.name));

            const existingItem = existingItems.find(i => i.content && i.content.id === contentId);
            let itemId;
            if (existingItem) { itemId = existingItem.id; }
            else {
              const m = `mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) { item { id } }
              }`;
              const r = await github.graphql(m, { projectId, contentId });
              itemId = r.addProjectV2ItemById.item.id;
            }

            function getField(name){ return fields.find(f => f.name === name); }
            async function setSingleSelect(fieldName, optionName){
              const f = getField(fieldName);
              if (!f || f.dataType !== 'SINGLE_SELECT') return false;
              const opt = (f.options || []).find(o => o.name.toLowerCase() === optionName.toLowerCase());
              if (!opt) return false;
              const m = `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }}) { projectV2Item { id } }
              }`;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, optionId: opt.id });
              return true;
            }
            async function setDate(fieldName, value){
              const f = getField(fieldName); if (!f || f.dataType !== 'DATE') return;
              const m = `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: Date!) {
                updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ date:$v }}) { projectV2Item { id } }
              }`;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, v: value });
            }
            async function setNumber(fieldName, value){
              const f = getField(fieldName); if (!f || f.dataType !== 'NUMBER') return;
              const m = `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: Float!) {
                updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ number:$v }}) { projectV2Item { id } }
              }`;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, v: value });
            }
            async function setText(fieldName, value, { overwrite = true } = {}){
              const f = getField(fieldName); if (!f || f.dataType !== 'TEXT') return;
              if (!overwrite && (!value || !String(value).trim())) return;
              const m = `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: String!) {
                updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ text:$v }}) { projectV2Item { id } }
              }`;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, v: value });
            }

            // Mappings (sama)
            if (labels.has('P0') || labels.has('urgent')) await setSingleSelect('Priority', 'P0');
            else if (labels.has('P1') || labels.has('high-priority')) await setSingleSelect('Priority', 'P1');
            else if (labels.has('P2') || labels.has('medium')) await setSingleSelect('Priority', 'P2');
            else if (labels.has('P3') || labels.has('planned')) await setSingleSelect('Priority', 'P3');

            const areaLabel = Array.from(labels).find(l => l.toLowerCase().startsWith('area:'));
            if (areaLabel) {
              const desired = areaLabel.slice('area:'.length).replace(/-/g,' ');
              const ok = await setSingleSelect('Area', desired);
              if (!ok) {
                // Fallback: if any label matches an existing Area option, use it
                const areaField = getField('Area');
                const labelSetLc = new Set(Array.from(labels).map(s=>s.toLowerCase()));
                const hit = (areaField?.options || []).find(o => labelSetLc.has(o.name.toLowerCase()));
                if (hit) await setSingleSelect('Area', hit.name);
              }
            }

            const phaseLabel = Array.from(labels).find(l => l.toLowerCase().startsWith('phase:'));
            if (phaseLabel) {
              const raw = phaseLabel.slice('phase:'.length).toLowerCase();
              const map = new Map([
                ['1','Phase 1'],['2-week-1','Phase 2 W1'],['2-week-2','Phase 2 W2'],['2-week-3','Phase 2 W3'],
                ['2-week-4','Phase 2 W4'],['2-week-5','Phase 2 W5'],['2-week-6','Phase 2 W6'],['2-week-7','Phase 2 W7'],
                ['2-week-8','Phase 2 W8'],['3-q1','Phase 3 Q1'],['3-q2','Phase 3 Q2'],['3-q3','Phase 3 Q3'],['3-q4','Phase 3 Q4'],
              ]);
              const target = map.get(raw); if (target) await setSingleSelect('Phase', target);
            }

            if (labels.has('risk:low')) await setSingleSelect('Risk', 'Low');
            else if (labels.has('risk:medium')) await setSingleSelect('Risk', 'Medium');
            else if (labels.has('risk:high')) await setSingleSelect('Risk', 'High');

            if (labels.has('status:todo')) await setSingleSelect('Status', 'To Do');
            else if (labels.has('status:in-progress')) await setSingleSelect('Status', 'In Progress');
            else if (labels.has('status:in-review')) await setSingleSelect('Status', 'In Review');
            else if (labels.has('status:blocked')) await setSingleSelect('Status', 'Blocked');
            else if (labels.has('status:done')) await setSingleSelect('Status', 'Done');
            else {
              if (context.payload.action === 'opened') await setSingleSelect('Status', 'To Do');
              if (context.payload.action === 'closed' && (context.payload.issue?.state === 'closed' || context.payload.pull_request?.merged)) {
                await setSingleSelect('Status', 'Done');
              }
            }

            const startDateLabel = Array.from(labels).find(l => l.startsWith('start:'));
            if (startDateLabel) {
              const dateStr = startDateLabel.slice('start:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) await setDate('Start date', dateStr);
            }
            const dueDateLabel = Array.from(labels).find(l => l.startsWith('due:'));
            if (dueDateLabel) {
              const dateStr = dueDateLabel.slice('due:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) await setDate('Target date', dateStr);
            } else if (content.milestone?.dueOn) {
              await setDate('Target date', content.milestone.dueOn.split('T')[0]);
            }

            const estimateLabel = Array.from(labels).find(l => l.startsWith('est:h:'));
            if (estimateLabel) {
              const hours = parseFloat(estimateLabel.slice('est:h:'.length));
              if (!isNaN(hours) && hours > 0) await setNumber('Estimate (h)', hours);
            }

            const firstAssignee = content.assignees?.nodes?.[0]?.login;
            if (firstAssignee) await setText('Owner (text)', firstAssignee);
            const urlMatch = (content.body || '').match(/https?:\/\/\S+/);
            if (urlMatch) await setText('Links', urlMatch[0], { overwrite: false });

            console.log(`Updated fields for ${isPRContext ? 'PR' : 'issue'} #${number} in project "${projectTitle}".`);
