name: Auto-add to Project

on:
  issues:
    types: [opened, labeled, unlabeled, reopened, edited, closed]
  pull_request:
    types: [opened, labeled, unlabeled, reopened, edited, closed, synchronize]
  issue_comment:
    types: [created]

jobs:
  add-to-project:
    runs-on: ubuntu-latest
    steps:
      - name: Add item and set fields
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }} # Classic PAT
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN }}
          script: |
            // Check for comment command trigger
            if (context.eventName === 'issue_comment') {
              const comment = context.payload.comment.body.trim().toLowerCase();
              if (!comment.includes('+project')) {
                console.log('Comment does not contain "+project" command, skipping');
                return;
              }
              console.log('Comment contains "+project" command, proceeding');
            }
            
            // Project selection: use repository variables if available, fallback to constants
            const ownerLogin = process.env.PROJECT_OWNER || '${{ vars.PROJECT_OWNER }}' || 'Andhika-Rey';
            const projectTitle = process.env.PROJECT_TITLE || '${{ vars.PROJECT_TITLE }}' || 'MerajutASA Program Board';

            // 1) Cari Project
            const findProjectQuery = `
              query($owner:String!) {
                user(login: $owner) {
                  projectsV2(first: 50) { nodes { id title fields(first: 50) {
                    nodes {
                      id name dataType
                      ... on ProjectV2SingleSelectField { options { id name } }
                    }
                  }
                  items(first: 100) {
                    nodes { 
                      id 
                      content { 
                        ... on Issue { id number }
                        ... on PullRequest { id number }
                      }
                    }
                  }}}
                }
                organization(login: $owner) {
                  projectsV2(first: 50) { nodes { id title fields(first: 50) {
                    nodes {
                      id name dataType
                      ... on ProjectV2SingleSelectField { options { id name } }
                    }
                  }
                  items(first: 100) {
                    nodes { 
                      id 
                      content { 
                        ... on Issue { id number }
                        ... on PullRequest { id number }
                      }
                    }
                  }}}
                }
              }
            `;
            const projResp = await github.graphql(findProjectQuery, { owner: ownerLogin });
            const nodes = [
              ...(projResp.user?.projectsV2?.nodes || []),
              ...(projResp.organization?.projectsV2?.nodes || []),
            ];
            const project = nodes.find(p => p.title === projectTitle);
            if (!project) {
              console.log(`Project "${projectTitle}" not found under ${ownerLogin}.`);
              return;
            }
            const projectId = project.id;
            const fields = project.fields.nodes;
            const existingItems = project.items.nodes;

            // 2) Ambil Issue/PR dari event
            const [repoOwner, repoName] = process.env.GITHUB_REPOSITORY.split('/');
            const isIssue = !!context.payload.issue || (context.eventName === 'issue_comment');
            const number = isIssue ? 
              (context.payload.issue?.number || context.payload.issue?.number) : 
              context.payload.pull_request.number;

            const contentQuery = `
              query($owner:String!, $repo:String!, $number:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$number) { 
                    id number title 
                    labels(first:50){ nodes { name } }
                    milestone { title dueOn }
                  }
                  pullRequest(number:$number) { 
                    id number title 
                    labels(first:50){ nodes { name } }
                    milestone { title dueOn }
                  }
                }
              }
            `;
            const contentResp = await github.graphql(contentQuery, { owner: repoOwner, repo: repoName, number });
            const content = isIssue ? contentResp.repository.issue : contentResp.repository.pullRequest;
            const contentId = content.id;
            const labels = new Set((content.labels?.nodes || []).map(l => l.name));

            // Check if item already exists in project (idempotent)
            const existingItem = existingItems.find(item => 
              item.content && item.content.id === contentId
            );
            
            let itemId;
            if (existingItem) {
              console.log(`${isIssue ? 'Issue' : 'PR'} #${number} already exists in project, reusing item`);
              itemId = existingItem.id;
            } else {
              // 3) Tambahkan ke Project
              const addItemMutation = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }
              `;
              const addResp = await github.graphql(addItemMutation, { projectId, contentId });
              itemId = addResp.addProjectV2ItemById.item.id;
              console.log(`Added ${isIssue ? 'issue' : 'PR'} #${number} to project`);
            }

            // Helpers
            function getField(name) { return fields.find(f => f.name === name); }
            async function setSingleSelect(fieldName, optionName) {
              const f = getField(fieldName);
              if (!f || f.dataType !== 'SINGLE_SELECT') return;
              const opt = (f.options || []).find(o => o.name.toLowerCase() === optionName.toLowerCase());
              if (!opt) return;
              const m = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ singleSelectOptionId:$optionId }
                  }) { projectV2Item { id } }
                }
              `;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, optionId: opt.id });
            }
            async function setDate(fieldName, dateValue) {
              const f = getField(fieldName);
              if (!f || f.dataType !== 'DATE') return;
              const m = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $dateValue: Date!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ date: $dateValue }
                  }) { projectV2Item { id } }
                }
              `;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, dateValue });
            }
            async function setNumber(fieldName, numberValue) {
              const f = getField(fieldName);
              if (!f || f.dataType !== 'NUMBER') return;
              const m = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $numberValue: Float!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ number: $numberValue }
                  }) { projectV2Item { id } }
                }
              `;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, numberValue });
            }
            async function setText(fieldName, textValue) {
              const f = getField(fieldName);
              if (!f || f.dataType !== 'TEXT') return;
              const m = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $textValue: String!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ text: $textValue }
                  }) { projectV2Item { id } }
                }
              `;
              await github.graphql(m, { projectId, itemId, fieldId: f.id, textValue });
            }

            // 4) Comprehensive field mapping
            
            // Priority mapping
            if (labels.has('P0') || labels.has('urgent')) await setSingleSelect('Priority', 'P0');
            else if (labels.has('P1') || labels.has('high-priority')) await setSingleSelect('Priority', 'P1');
            else if (labels.has('P2') || labels.has('medium')) await setSingleSelect('Priority', 'P2');
            else if (labels.has('P3') || labels.has('planned')) await setSingleSelect('Priority', 'P3');

            // Area mapping
            const areaPrefix = 'area:';
            const areaLabel = Array.from(labels).find(l => l.toLowerCase().startsWith(areaPrefix));
            if (areaLabel) {
              const val = areaLabel.slice(areaPrefix.length).replace(/-/g, ' ');
              await setSingleSelect('Area', val);
            }

            // Phase mapping
            const phasePrefix = 'phase:';
            const phaseLabel = Array.from(labels).find(l => l.toLowerCase().startsWith(phasePrefix));
            if (phaseLabel) {
              const raw = phaseLabel.slice(phasePrefix.length).toLowerCase();
              const map = new Map([
                ['1', 'Phase 1'],
                ['2-week-1', 'Phase 2 W1'], ['2-week-2', 'Phase 2 W2'],
                ['2-week-3', 'Phase 2 W3'], ['2-week-4', 'Phase 2 W4'],
                ['2-week-5', 'Phase 2 W5'], ['2-week-6', 'Phase 2 W6'],
                ['2-week-7', 'Phase 2 W7'], ['2-week-8', 'Phase 2 W8'],
                ['3-q1', 'Phase 3 Q1'], ['3-q2', 'Phase 3 Q2'],
                ['3-q3', 'Phase 3 Q3'], ['3-q4', 'Phase 3 Q4'],
              ]);
              const target = map.get(raw);
              if (target) await setSingleSelect('Phase', target);
            }
            
            // Risk mapping
            if (labels.has('risk:low')) await setSingleSelect('Risk', 'Low');
            else if (labels.has('risk:medium')) await setSingleSelect('Risk', 'Medium');
            else if (labels.has('risk:high')) await setSingleSelect('Risk', 'High');
            
            // Status mapping with auto-setting based on events
            if (labels.has('status:todo')) await setSingleSelect('Status', 'To Do');
            else if (labels.has('status:in-progress')) await setSingleSelect('Status', 'In Progress');  
            else if (labels.has('status:in-review')) await setSingleSelect('Status', 'In Review');
            else if (labels.has('status:blocked')) await setSingleSelect('Status', 'Blocked');
            else if (labels.has('status:done')) await setSingleSelect('Status', 'Done');
            else {
              // Auto-set status based on events
              if (context.payload.action === 'opened' && !labels.has('status:in-progress') && !labels.has('status:in-review') && !labels.has('status:blocked') && !labels.has('status:done')) {
                await setSingleSelect('Status', 'To Do');
              } else if (labels.has('in-progress')) {
                await setSingleSelect('Status', 'In Progress');
              } else if ((context.payload.action === 'closed' && context.payload.issue?.state === 'closed') || 
                         (context.payload.action === 'closed' && context.payload.pull_request?.merged)) {
                await setSingleSelect('Status', 'Done');
              }
            }
            
            // Date parsing from labels (start:YYYY-MM-DD, due:YYYY-MM-DD)
            const startDateLabel = Array.from(labels).find(l => l.startsWith('start:'));
            if (startDateLabel) {
              const dateStr = startDateLabel.slice('start:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                await setDate('Start date', dateStr);
              }
            }
            
            const dueDateLabel = Array.from(labels).find(l => l.startsWith('due:'));
            if (dueDateLabel) {
              const dateStr = dueDateLabel.slice('due:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                await setDate('Target date', dateStr);
              }
            } else if (content.milestone?.dueOn) {
              // Use milestone due date if no label provided
              const milestoneDate = content.milestone.dueOn.split('T')[0]; // Get YYYY-MM-DD part
              await setDate('Target date', milestoneDate);
            }
            
            // Estimate parsing from labels (est:h:XX)
            const estimateLabel = Array.from(labels).find(l => l.startsWith('est:h:'));
            if (estimateLabel) {
              const hoursStr = estimateLabel.slice('est:h:'.length);
              const hours = parseFloat(hoursStr);
              if (!isNaN(hours) && hours > 0) {
                await setNumber('Estimate (h)', hours);
              }
            }
            
            // Set milestone text field if milestone exists
            if (content.milestone?.title) {
              await setText('Milestone', content.milestone.title);
            }

            console.log(`Updated fields for ${isIssue ? 'issue' : 'PR'} #${number} in project "${projectTitle}".`);