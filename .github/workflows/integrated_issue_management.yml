name: Integrated Issue Management (Personal Account)

# Workflow that combines auto-labeling and project management
# Created: 2025-08-20
# Author: Andhika-Rey
# Version: 1.1.0

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      project_title:
        description: 'Project title to target'
        required: false
        default: "MerajutASA Program Board"
      area:
        description: 'Override area classification'
        required: false
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  DEFAULT_PROJECT_TITLE: "MerajutASA Program Board"
  WORKFLOW_VERSION: "1.1.0"
  CREATED_AT: "2025-08-20"
  UPDATED_AT: "2025-08-20 04:36:03"
  CREATED_BY: "Andhika-Rey"

jobs:
  # Step 1: Extract information and classify the issue/PR
  classify:
    name: "🔍 Extract & Classify"
    runs-on: ubuntu-latest
    outputs:
      item_number: ${{ steps.extract_info.outputs.item_number }}
      item_type: ${{ steps.extract_info.outputs.item_type }}
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      has_item: ${{ steps.extract_info.outputs.has_item }}
      node_id: ${{ steps.extract_info.outputs.node_id }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Extract Item Information
        id: extract_info
        uses: actions/github-script@v7
        with:
          script: |
            const { eventName, payload, repo } = context;
            const owner = repo.owner;
            const repoName = repo.repo;
            
            let isPR = eventName === 'pull_request';
            let number = null;
            let hasItem = false;
            let nodeId = null;
            
            // Handle different event types to extract item number
            if (eventName === 'pull_request') {
              number = payload.pull_request.number;
              nodeId = payload.pull_request.node_id;
              hasItem = true;
            } else if ((eventName === 'issues' || eventName === 'issue_comment') && payload.issue) {
              number = payload.issue.number;
              nodeId = payload.issue.node_id;
              isPR = !!payload.issue.pull_request;
              hasItem = true;
            } else if (eventName === 'workflow_dispatch' && payload.inputs && payload.inputs.number) {
              number = parseInt(payload.inputs.number, 10);
              if (!isNaN(number)) {
                // Determine if number refers to a PR
                try {
                  const pr = await github.rest.pulls.get({
                    owner,
                    repo: repoName,
                    pull_number: number
                  });
                  isPR = true;
                  nodeId = pr.data.node_id;
                  hasItem = true;
                } catch (e) {
                  try {
                    const issue = await github.rest.issues.get({
                      owner,
                      repo: repoName,
                      issue_number: number
                    });
                    isPR = false;
                    nodeId = issue.data.node_id;
                    hasItem = true;
                  } catch (e) {
                    core.warning(`Item #${number} not found as issue or PR`);
                    hasItem = false;
                  }
                }
              }
            }
            
            if (hasItem) {
              core.info(`✅ Found ${isPR ? 'PR' : 'Issue'} #${number}`);
              if (nodeId) {
                core.info(`📌 Node ID: ${nodeId}`);
              } else {
                core.warning('⚠️ No Node ID found, will try to fetch it in next step');
              }
            } else {
              core.warning('⚠️ No valid issue/PR number found in this event');
            }
            
            core.setOutput('item_number', number ? number.toString() : '');
            core.setOutput('item_type', isPR ? 'pull_request' : 'issue');
            core.setOutput('has_item', hasItem ? 'true' : 'false');
            if (nodeId) {
              core.setOutput('node_id', nodeId);
            }

      # Skip the rest if no valid item was found
      - name: Check for valid item
        id: check_item
        if: steps.extract_info.outputs.has_item != 'true'
        run: |
          echo "::notice::No valid issue or PR found to process"
          exit 0

      - name: Fetch Item Details
        id: fetch_details
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
            const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            let title = '', body = '', labels = [], milestoneTitle = '';
            let prState = null, isDraft = false, merged = false, issueState = null;
            let item = null;
            let nodeId = '${{ steps.extract_info.outputs.node_id }}';
            let assignees = [], comments = 0, commentsData = [];
            let createdAt, updatedAt;
            let author = null;
            let files = [], additions = 0, deletions = 0, changes = 0;
            
            try {
              if (isPR) {
                const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                item = pr;
                title = pr.title || '';
                body = pr.body || '';
                labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = pr.milestone?.title || '';
                prState = typeof pr.state === 'string' ? pr.state.toLowerCase() : null;
                isDraft = !!pr.draft;
                merged = !!pr.merged;
                if (!nodeId) nodeId = pr.node_id;
                assignees = pr.assignees?.map(a => a.login) || [];
                author = pr.user?.login;
                createdAt = pr.created_at;
                updatedAt = pr.updated_at;
                
                // Get PR comments
                const prComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = prComments.data.length;
                commentsData = prComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                }));
                
                // Get PR review comments
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner, repo, pull_number: number, per_page: 100
                });
                comments += reviewComments.data.length;
                commentsData.push(...reviewComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                })));
                
                // Get PR files
                const perPage = 100;
                let page = 1;
                while (true) {
                  try {
                    const resp = await github.rest.pulls.listFiles({ 
                      owner, repo, pull_number: number, per_page: perPage, page 
                    });
                    files.push(...resp.data);
                    if (resp.data.length < perPage) break;
                    page += 1;
                  } catch (e) {
                    core.warning(`Failed to get PR files page ${page}: ${e.message}`);
                    break;
                  }
                }
                additions = files.reduce((s, f) => s + (f.additions || 0), 0);
                deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
                changes = files.reduce((s, f) => s + (f.changes || 0), 0);
              } else {
                const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                item = issue;
                title = issue.title || '';
                body = issue.body || '';
                labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = issue.milestone?.title || '';
                issueState = typeof issue.state === 'string' ? issue.state.toLowerCase() : null;
                if (!nodeId) nodeId = issue.node_id;
                assignees = issue.assignees?.map(a => a.login) || [];
                author = issue.user?.login;
                createdAt = issue.created_at;
                updatedAt = issue.updated_at;
                
                // Get issue comments
                const issueComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = issueComments.data.length;
                commentsData = issueComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login, 
                  created_at: c.created_at
                }));
              }
              
              core.info(`📝 Title: ${title}`);
              core.info(`👤 Author: ${author || 'Unknown'}`);
              core.info(`💬 Comments: ${comments}`);
              core.info(`📅 Created: ${createdAt}`);
              
              if (isPR) {
                core.info(`📊 PR Stats: +${additions} -${deletions} changes: ${changes}`);
              }
              
            } catch (e) {
              core.warning(`⚠️ Error fetching details: ${e.message}`);
            }
            
            // Save to outputs for next steps
            return {
              item: {
                number,
                title,
                body,
                isPR,
                labels,
                nodeId,
                milestoneTitle,
                state: isPR ? prState : issueState,
                isDraft,
                merged,
                assignees,
                author,
                createdAt,
                updatedAt,
                comments,
                commentsData
              },
              files: {
                list: files.map(f => ({ filename: f.filename, additions: f.additions, deletions: f.deletions })),
                stats: { additions, deletions, changes }
              }
            };

      - name: Analyze and Apply Labels
        id: auto_labeler
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Load or use the classify module
            async function classifyItem() {
              const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
              const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
              const nodeId = '${{ steps.extract_info.outputs.node_id }}';
              const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
              const areaOverride = '${{ github.event.inputs.area }}';
              const itemDetails = ${{ toJSON(steps.fetch_details.outputs.result) }};
              
              // Prevent relabel loops when the actor is the bot itself
              if ((context.eventName === 'issues' && ['labeled','unlabeled'].includes(context.payload.action)) ||
                  (context.eventName === 'pull_request' && ['labeled','unlabeled'].includes(context.payload.action))) {
                if (context.actor === 'github-actions[bot]') {
                  core.info('Skip to prevent relabel loop (actor is github-actions[bot]).');
                  return { skipped: true, reason: 'bot_actor' };
                }
              }
              
              // Including classify.js content inline
              // Full classify.js content would go here - abbreviated for readability
              
              // Extract item details
              const item = itemDetails.item;
              const files = itemDetails.files;
              
              // Extract all the details we need
              const title = item.title || '';
              const body = item.body || '';
              const labels = item.labels || [];
              const milestoneTitle = item.milestoneTitle || '';
              const assignees = item.assignees || [];
              const author = item.author;
              const commentsData = item.commentsData || [];
              
              // Enhanced content analysis with multiple approaches
              const allContent = [
                title,
                body,
                ...commentsData.map(c => c.body)
              ].filter(Boolean).join('\n').toLowerCase();
              
              const filePaths = (files.list || []).map(f => (f.filename || '').toLowerCase());
              const additions = files.stats?.additions || 0;
              const deletions = files.stats?.deletions || 0;
              const changes = files.stats?.changes || 0;
              
              // Define word lists for better classification
              const securityTerms = ['security', 'auth', 'authentication', 'authorization', 'login', 'password'];
              const monitoringTerms = ['monitor', 'metrics', 'grafana', 'prometheus', 'logging', 'trace', 'observability'];
              const performanceTerms = ['performance', 'optimize', 'optimization', 'speed', 'fast', 'slow', 'latency'];
              const containerTerms = ['kubernetes', 'k8s', 'container', 'docker', 'pod', 'cluster', 'orchestration'];
              const cicdTerms = ['ci', 'cd', 'continuous integration', 'continuous delivery', 'pipeline', 'github actions'];
              const dataTerms = ['database', 'db', 'sql', 'nosql', 'mongodb', 'postgres', 'mysql', 'redis', 'migration'];
              const apiTerms = ['api', 'rest', 'graphql', 'endpoint', 'gateway', 'service', 'microservice', 'route'];
              const docsTerms = ['documentation', 'doc', 'readme', 'wiki', 'guide', 'tutorial', 'manual', 'instruction'];
              const uiTerms = ['ui', 'ux', 'user interface', 'design', 'layout', 'css', 'html', 'front-end', 'frontend'];
              
              // Helper functions for classification
              const hasAny = (s, arr) => arr.some(k => s.includes(k));
              const pathHasAny = (arr) => filePaths.some(p => arr.some(k => p.includes(k)));
              
              function countTerms(text, termList) {
                if (!text) return 0;
                let count = 0;
                for (const term of termList) {
                  const regex = new RegExp('\\b' + term + '\\b', 'gi');
                  const matches = text.match(regex);
                  count += matches ? matches.length : 0;
                }
                return count;
              }
              
              function confidenceScore(count, threshold = 2) {
                if (count === 0) return 0;
                if (count === 1) return 0.5;
                if (count <= threshold) return 0.75;
                return 0.9 + Math.min(0.09, (count - threshold) * 0.01);
              }
              
              // Special handling for "test" issues
              const minimalContent = title.length + (body?.length || 0) < 20;
              let bestArea = null;
              let bestScore = 0.3;
              
              if (minimalContent && title.toLowerCase().includes('test') && (!body || body.length < 20)) {
                bestArea = 'monitoring-observability'; // QA related
                bestScore = 0.6;
                core.info('✅ Test-related issue/PR detected, classified as monitoring-observability');
              } else {
                // Regular area classification with confidence scores
                let areaScores = {
                  'security-layer': confidenceScore(
                    countTerms(allContent, securityTerms) + 
                    (pathHasAny(['auth', 'security', 'oauth', 'jwt', 'encryption', 'passport', 'login']) ? 3 : 0)
                  ),
                  'monitoring-observability': confidenceScore(
                    countTerms(allContent, monitoringTerms) + 
                    (pathHasAny(['monitor', 'metrics', 'grafana', 'prometheus', 'logging', 'trace']) ? 3 : 0)
                  ),
                  'performance-optimization': confidenceScore(
                    countTerms(allContent, performanceTerms) + 
                    (pathHasAny(['cache', 'optimization', 'perf', 'cdn', 'compression']) ? 3 : 0)
                  ),
                  'container-orchestration': confidenceScore(
                    countTerms(allContent, containerTerms) + 
                    (pathHasAny(['k8s', 'kubernetes', 'helm', 'manifests', 'charts', 'docker']) ? 3 : 0)
                  ),
                  'cicd-pipeline': confidenceScore(
                    countTerms(allContent, cicdTerms) + 
                    (pathHasAny(['.github/workflows', 'deploy', 'pipeline', 'ci', 'cd', '.gitlab-ci', 'jenkins']) ? 3 : 0)
                  ),
                  'data-management': confidenceScore(
                    countTerms(allContent, dataTerms) + 
                    (pathHasAny(['backup', 'migrations', 'db/', 'database', 'storage', 's3', 'mongo', 'sql']) ? 3 : 0)
                  ),
                  'api-gateway-services': confidenceScore(
                    countTerms(allContent, apiTerms) + 
                    (pathHasAny(['api/', 'gateway', 'ingress', 'service', 'routes', 'controller']) ? 3 : 0)
                  ),
                  'docs': confidenceScore(
                    countTerms(allContent, docsTerms) + 
                    (pathHasAny(['docs/', 'documentation', 'wiki', 'readme', '.md']) ? 3 : 0)
                  ),
                  'ui-components': confidenceScore(
                    countTerms(allContent, uiTerms) + 
                    (pathHasAny(['ui/', 'components', 'css', 'html', 'jsx', 'tsx', 'vue', 'react']) ? 3 : 0)
                  )
                };
                
                // Find the area with highest score
                for (const [area, score] of Object.entries(areaScores)) {
                  if (score > bestScore) {
                    bestArea = area;
                    bestScore = score;
                  }
                }
                
                // Log area classification results
                core.info('📊 Area classification scores:');
                for (const [area, score] of Object.entries(areaScores)) {
                  if (score > 0) {
                    core.info(`  - ${area}: ${score.toFixed(2)}`);
                  }
                }
              }
              
              // Apply manual override if provided
              if (areaOverride) {
                const validAreas = [
                  'security-layer', 'monitoring-observability', 'performance-optimization',
                  'container-orchestration', 'cicd-pipeline', 'data-management', 
                  'api-gateway-services', 'docs', 'ui-components'
                ];
                
                if (validAreas.includes(areaOverride)) {
                  bestArea = areaOverride;
                  bestScore = 1.0;
                  core.info(`🔧 Manual area override applied: ${areaOverride}`);
                }
              }
              
              // Risk, status, team, size, health, and iteration classification
              // Simplified for brevity but still handling test issues specially
              let risk = minimalContent && title.toLowerCase().includes('test') ? 'risk:low' : 'risk:medium';
              let status = minimalContent && title.toLowerCase().includes('test') ? 'status:todo' : 'status:in-progress';
              let team = bestArea === 'monitoring-observability' ? 'team:qa' : 'team:backend-dev';
              let size = minimalContent && title.toLowerCase().includes('test') ? 'size:small' : 'size:medium';
              let health = minimalContent && title.toLowerCase().includes('test') ? 'health:75-89' : 'health:50-74';
              
              const area = bestArea ? `area:${bestArea}` : null;
              
              core.info(`📍 Selected area: ${bestArea || 'None'} (score: ${bestScore.toFixed(2)})`);
              core.info(`🚨 Risk classification: ${risk}`);
              
              // Apply labels
              const existing = new Set(labels);
              const toAdd = new Set();
              const toRemove = new Set();
              
              if (area && !existing.has(area)) toAdd.add(area);
              if (!existing.has(risk)) toAdd.add(risk);
              if (!existing.has(status)) toAdd.add(status);
              if (!existing.has(team)) toAdd.add(team);
              if (!existing.has(size)) toAdd.add(size);
              if (!existing.has(health)) toAdd.add(health);
              
              const addList = Array.from(toAdd);
              const removeList = Array.from(toRemove);
              
              // Record classifications
              const classifications = {
                area: area ? { value: area.split(':')[1], confidence: bestScore.toFixed(2) } : null,
                risk: risk ? { value: risk.split(':')[1] } : null,
                status: status ? { value: status.split(':')[1] } : null,
                team: team ? { value: team.split(':')[1] } : null,
                size: size ? { value: size.split(':')[1] } : null,
                health: health ? { value: health.split(':')[1] } : null
              };
              
              // Apply or dry-run
              if (dryRun) {
                core.info('🧪 DRY RUN: Label changes preview');
                core.info(`Would add: ${addList.join(', ') || 'None'}`);
                return {
                  dryRun: true,
                  item: {
                    type: isPR ? 'pull_request' : 'issue',
                    number: number,
                    title: title,
                    url: item.url,
                    node_id: nodeId,
                    author: author
                  },
                  labels: { existing: Array.from(existing), toAdd: addList, toRemove: removeList },
                  classifications: classifications
                };
              }
              
              // Apply labels
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              if (addList.length) {
                try {
                  await github.rest.issues.addLabels({ 
                    owner, repo, issue_number: number, labels: addList 
                  });
                  core.info(`Added labels: ${addList.join(', ')}`);
                } catch (e) {
                  core.warning(`Failed to add labels: ${e.message}`);
                }
              }
              
              const finalLabels = [...labels.filter(l => !removeList.includes(l)), ...addList];
              
              return {
                item: {
                  type: isPR ? 'pull_request' : 'issue',
                  number: number,
                  title: title,
                  body: body,
                  url: item.url,
                  state: item.state,
                  isPR: isPR,
                  node_id: nodeId,
                  author: author
                },
                labels: { final: finalLabels, added: addList, removed: removeList },
                classifications: classifications
              };
            }
            
            // Execute the classification
            const result = await classifyItem();
            return result;

      - name: Create Classification Artifact
        id: create_artifact
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            
            // Get the classification results from the previous step
            const result = ${{ toJSON(steps.auto_labeler.outputs.result) }};
            
            // Add metadata
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                updated_at: process.env.UPDATED_AT,
                version: process.env.WORKFLOW_VERSION,
                user: context.actor,
                event_type: context.eventName,
                action: context.payload.action || 'manual',
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`
              },
              ...result
            };
            
            // Ensure node_id is present
            if (!artifactData.item || !artifactData.item.node_id) {
              if ('${{ steps.extract_info.outputs.node_id }}') {
                if (!artifactData.item) artifactData.item = {};
                artifactData.item.node_id = '${{ steps.extract_info.outputs.node_id }}';
                core.info('📌 Added node_id from extract_info step to artifact');
              } else {
                core.warning('⚠️ No node_id available in classification or extract_info outputs');
              }
            }
            
            // Write to file
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            core.info('💾 Created classification artifact with the following data:');
            core.info(`- Item type: ${artifactData.item?.type || 'Unknown'}`);
            core.info(`- Item number: ${artifactData.item?.number || 'Unknown'}`);
            core.info(`- Node ID present: ${artifactData.item?.node_id ? 'Yes' : 'No'}`);
            
            core.setOutput('artifact_name', artifactName);
            
      - name: Upload Classification Artifact
        if: steps.extract_info.outputs.has_item == 'true' && steps.create_artifact.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 1

  # Step 2: Add to Project with classification data
  project_integration:
    name: "📋 Project Integration"
    needs: classify
    if: needs.classify.outputs.has_item == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Classification Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}
          
      - name: Debug Classification Data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              const data = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('📊 Classification Data Debug:');
              core.info(`- File exists: Yes`);
              core.info(`- Has metadata: ${data.metadata ? 'Yes' : 'No'}`);
              core.info(`- Has item: ${data.item ? 'Yes' : 'No'}`);
              
              if (data.item) {
                core.info(`- Item number: ${data.item.number || 'Not found'}`);
                core.info(`- Item type: ${data.item.type || 'Not found'}`);
                core.info(`- Node ID: ${data.item.node_id || 'Not found'}`);
              }
              
              if (!data.item?.node_id) {
                // Try to fetch node_id directly as fallback
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                const number = data.item?.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
                const isPR = data.item?.type === 'pull_request' || '${{ needs.classify.outputs.item_type }}' === 'pull_request';
                
                if (number) {
                  core.info(`🔄 Attempting to fetch node_id for ${isPR ? 'PR' : 'Issue'} #${number} as fallback...`);
                  
                  try {
                    if (isPR) {
                      const pr = await github.rest.pulls.get({owner, repo, pull_number: number});
                      data.item.node_id = pr.data.node_id;
                    } else {
                      const issue = await github.rest.issues.get({owner, repo, issue_number: number});
                      data.item.node_id = issue.data.node_id;
                    }
                    
                    if (data.item.node_id) {
                      core.info(`✅ Successfully retrieved node_id: ${data.item.node_id}`);
                      fs.writeFileSync('classification.json', JSON.stringify(data, null, 2));
                    }
                  } catch (e) {
                    core.warning(`❌ Failed to fetch node_id: ${e.message}`);
                  }
                }
              }
            } catch (e) {
              core.error(`❌ Failed to parse classification.json: ${e.message}`);
            }

      - name: Add to Project with Classification
        uses: actions/github-script@v7
        env:
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
          PROJECT_TITLE: ${{ github.event.inputs.project_title || env.DEFAULT_PROJECT_TITLE }}
          NODE_ID_FALLBACK: ${{ needs.classify.outputs.node_id }}
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const isDryRun = !process.env.GH_PROJECT_TOKEN || '${{ github.event.inputs.dry_run }}' === 'true';
            const projectTitle = process.env.PROJECT_TITLE || 'MerajutASA Program Board';
            const nodeIdFallback = process.env.NODE_ID_FALLBACK;
            
            // Load classification data
            let classification;
            try {
              classification = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('✅ Loaded classification data');
            } catch (e) {
              core.setFailed(`Failed to load classification data: ${e.message}`);
              return;
            }
            
            // Extract key information
            const item = classification.item || {};
            const classifications = classification.classifications || {};
            const labels = classification.labels?.final || [];
            
            const itemType = item.type || '${{ needs.classify.outputs.item_type }}';
            const itemNumber = item.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
            const isPR = itemType === 'pull_request';
            
            // Get node_id from classification data or fallback
            let contentId = item.node_id || nodeIdFallback;
            
            // If still no node_id, fetch it directly
            if (!contentId) {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              try {
                core.info(`🔄 No node_id found in data, fetching directly for ${isPR ? 'PR' : 'Issue'} #${itemNumber}...`);
                
                if (isPR) {
                  const pr = await github.rest.pulls.get({owner, repo, pull_number: itemNumber});
                  contentId = pr.data.node_id;
                } else {
                  const issue = await github.rest.issues.get({owner, repo, issue_number: itemNumber});
                  contentId = issue.data.node_id;
                }
                
                if (contentId) {
                  core.info(`✅ Successfully retrieved node_id: ${contentId}`);
                }
              } catch (e) {
                core.setFailed(`Failed to fetch node_id: ${e.message}`);
                return;
              }
            }
            
            if (!contentId) {
              core.setFailed('Missing node_id. Cannot add to project.');
              return;
            }
            
            // Project configuration
            const ownerLogin = context.repo.owner;
            
            core.info(`🎯 Processing ${isPR ? 'PR' : 'Issue'} #${itemNumber} for project "${projectTitle}"`);
            core.info(`Using node ID: ${contentId}`);
            
            if (isDryRun) {
              core.info('🧪 DRY RUN MODE: Will simulate but not make actual changes');
              return;
            }
            
            // Project lookup
            const projectQuery = `
              query($owner: String!) {
                repositoryOwner(login: $owner) {
                  id
                  login
                  ... on User {
                    projectsV2(first: 20) {
                      nodes {
                        id title url public
                        fields(first: 50) {
                          nodes {
                            __typename
                            ... on ProjectV2FieldCommon { id name dataType }
                            ... on ProjectV2SingleSelectField { 
                              id name dataType 
                              options { id name color description } 
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const resp = await github.graphql(projectQuery, { owner: ownerLogin });
            const nodes = resp.repositoryOwner?.projectsV2?.nodes || [];
            
            const project = nodes.find(p => p.title === projectTitle)
                  || nodes.find(p => p.title.toLowerCase() === projectTitle.toLowerCase())
                  || nodes.find(p => p.title === 'MerajutASA Program Board');
                  
            if (!project) {
              core.warning(`❌ Project "${projectTitle}" not found in ${ownerLogin}'s account`);
              core.info('💡 Available projects:');
              for (const p of nodes) {
                core.info(`- ${p.title}`);
              }
              return;
            }
            
            core.info(`✅ Using project: ${project.title} (${project.url || 'N/A'})`);
            
            // The rest of the project integration logic follows
            const projectId = project.id;
            
            // Check if already in project
            const itemQuery = `
              query($projectId: ID!, $first: Int = 100) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: $first) {
                      nodes {
                        id
                        content {
                          ... on Issue { id number repository { nameWithOwner } }
                          ... on PullRequest { id number repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const itemsResp = await github.graphql(itemQuery, { projectId });
            const items = itemsResp.node.items.nodes;
            
            const repoFullName = `${context.repo.owner}/${context.repo.repo}`;
            const existingItem = items.find(i => 
              i.content && 
              i.content.number === itemNumber && 
              i.content.repository?.nameWithOwner === repoFullName
            );
            
            let itemId;
            if (existingItem) {
              itemId = existingItem.id;
              core.info(`🔄 Item already exists in project, ID: ${itemId}`);
            } else {
              // Add item to project
              core.info(`➕ Adding ${isPR ? 'PR' : 'Issue'} #${itemNumber} to project`);
              
              try {
                const addMutation = `
                  mutation($projectId: ID!, $contentId: ID!) { 
                    addProjectV2ItemById(input: {
                      projectId: $projectId, 
                      contentId: $contentId
                    }) { 
                      item { id } 
                    } 
                  }
                `;
                
                core.info(`Using contentId: ${contentId}`);
                
                const addResult = await github.graphql(addMutation, { 
                  projectId, 
                  contentId 
                });
                
                itemId = addResult.addProjectV2ItemById.item.id;
                core.info(`✅ Added item with ID: ${itemId}`);
                
                // Write a summary 
                fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                  timestamp: new Date().toISOString(),
                  project: project.title,
                  item: {
                    type: itemType,
                    number: itemNumber,
                    added_to_project: true,
                  },
                  classifications: classifications
                }, null, 2));
                
              } catch (e) {
                core.setFailed(`Failed to add item to project: ${e.message}`);
                return;
              }
            }

      - name: Upload Integration Summary
        uses: actions/upload-artifact@v4
        with:
          name: project-integration-summary
          path: project-integration-summary.json
          retention-days: 7
          if-no-files-found: ignore