name: Integrated Issue Management (Personal Account)

# Workflow that combines auto-labeling and project management
# Created: 2025-08-20
# Author: Andhika-Rey
# Version: 1.1.0

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      project_title:
        description: 'Project title to target'
        required: false
        default: "MerajutASA Program Board"
      area:
        description: 'Override area classification'
        required: false
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  DEFAULT_PROJECT_TITLE: "MerajutASA Program Board"
  WORKFLOW_VERSION: "1.1.0"
  CREATED_AT: "2025-08-20"
  UPDATED_AT: "2025-08-20 04:24:51"
  CREATED_BY: "Andhika-Rey"

jobs:
  # Step 1: Extract information and classify the issue/PR
  classify:
    name: "🔍 Extract & Classify"
    runs-on: ubuntu-latest
    outputs:
      item_number: ${{ steps.extract_info.outputs.item_number }}
      item_type: ${{ steps.extract_info.outputs.item_type }}
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      has_item: ${{ steps.extract_info.outputs.has_item }}
      node_id: ${{ steps.extract_info.outputs.node_id }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: '.github'
          
      - name: Extract Item Information
        id: extract_info
        uses: actions/github-script@v7
        with:
          script: |
            const { eventName, payload, repo } = context;
            const owner = repo.owner;
            const repoName = repo.repo;
            
            let isPR = eventName === 'pull_request';
            let number = null;
            let hasItem = false;
            let nodeId = null;
            
            // Handle different event types to extract item number
            if (eventName === 'pull_request') {
              number = payload.pull_request.number;
              nodeId = payload.pull_request.node_id;
              hasItem = true;
            } else if ((eventName === 'issues' || eventName === 'issue_comment') && payload.issue) {
              number = payload.issue.number;
              nodeId = payload.issue.node_id;
              isPR = !!payload.issue.pull_request;
              hasItem = true;
            } else if (eventName === 'workflow_dispatch' && payload.inputs && payload.inputs.number) {
              number = parseInt(payload.inputs.number, 10);
              if (!isNaN(number)) {
                // Determine if number refers to a PR
                try {
                  const pr = await github.rest.pulls.get({
                    owner,
                    repo: repoName,
                    pull_number: number
                  });
                  isPR = true;
                  nodeId = pr.data.node_id;
                  hasItem = true;
                } catch (e) {
                  try {
                    const issue = await github.rest.issues.get({
                      owner,
                      repo: repoName,
                      issue_number: number
                    });
                    isPR = false;
                    nodeId = issue.data.node_id;
                    hasItem = true;
                  } catch (e) {
                    core.warning(`Item #${number} not found as issue or PR`);
                    hasItem = false;
                  }
                }
              }
            }
            
            if (hasItem) {
              core.info(`✅ Found ${isPR ? 'PR' : 'Issue'} #${number}`);
              if (nodeId) {
                core.info(`📌 Node ID: ${nodeId}`);
              } else {
                core.warning('⚠️ No Node ID found, will try to fetch it in next step');
              }
            } else {
              core.warning('⚠️ No valid issue/PR number found in this event');
            }
            
            core.setOutput('item_number', number ? number.toString() : '');
            core.setOutput('item_type', isPR ? 'pull_request' : 'issue');
            core.setOutput('has_item', hasItem ? 'true' : 'false');
            if (nodeId) {
              core.setOutput('node_id', nodeId);
            }

      # Skip the rest if no valid item was found
      - name: Check for valid item
        id: check_item
        if: steps.extract_info.outputs.has_item != 'true'
        run: |
          echo "::notice::No valid issue or PR found to process"
          exit 0

      - name: Fetch Item Details
        id: fetch_details
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
            const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            let title = '', body = '', labels = [], milestoneTitle = '';
            let prState = null, isDraft = false, merged = false, issueState = null;
            let item = null;
            let nodeId = '${{ steps.extract_info.outputs.node_id }}';
            let assignees = [], comments = 0, commentsData = [];
            let createdAt, updatedAt;
            let author = null;
            let files = [], additions = 0, deletions = 0, changes = 0;
            
            try {
              if (isPR) {
                const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                item = pr;
                title = pr.title || '';
                body = pr.body || '';
                labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = pr.milestone?.title || '';
                prState = typeof pr.state === 'string' ? pr.state.toLowerCase() : null;
                isDraft = !!pr.draft;
                merged = !!pr.merged;
                if (!nodeId) nodeId = pr.node_id;
                assignees = pr.assignees?.map(a => a.login) || [];
                author = pr.user?.login;
                createdAt = pr.created_at;
                updatedAt = pr.updated_at;
                
                // Get PR comments
                const prComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = prComments.data.length;
                commentsData = prComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                }));
                
                // Get PR review comments
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner, repo, pull_number: number, per_page: 100
                });
                comments += reviewComments.data.length;
                commentsData.push(...reviewComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                })));
                
                // Get PR files
                const perPage = 100;
                let page = 1;
                while (true) {
                  try {
                    const resp = await github.rest.pulls.listFiles({ 
                      owner, repo, pull_number: number, per_page: perPage, page 
                    });
                    files.push(...resp.data);
                    if (resp.data.length < perPage) break;
                    page += 1;
                  } catch (e) {
                    core.warning(`Failed to get PR files page ${page}: ${e.message}`);
                    break;
                  }
                }
                additions = files.reduce((s, f) => s + (f.additions || 0), 0);
                deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
                changes = files.reduce((s, f) => s + (f.changes || 0), 0);
              } else {
                const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                item = issue;
                title = issue.title || '';
                body = issue.body || '';
                labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = issue.milestone?.title || '';
                issueState = typeof issue.state === 'string' ? issue.state.toLowerCase() : null;
                if (!nodeId) nodeId = issue.node_id;
                assignees = issue.assignees?.map(a => a.login) || [];
                author = issue.user?.login;
                createdAt = issue.created_at;
                updatedAt = issue.updated_at;
                
                // Get issue comments
                const issueComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = issueComments.data.length;
                commentsData = issueComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login, 
                  created_at: c.created_at
                }));
              }
              
              core.info(`📝 Title: ${title}`);
              core.info(`👤 Author: ${author || 'Unknown'}`);
              core.info(`💬 Comments: ${comments}`);
              core.info(`📅 Created: ${createdAt}`);
              
              if (isPR) {
                core.info(`📊 PR Stats: +${additions} -${deletions} changes: ${changes}`);
              }
              
            } catch (e) {
              core.warning(`⚠️ Error fetching details: ${e.message}`);
            }
            
            // Save to outputs for next steps
            return {
              item: {
                number,
                title,
                body,
                isPR,
                labels,
                nodeId,
                milestoneTitle,
                state: isPR ? prState : issueState,
                isDraft,
                merged,
                assignees,
                author,
                createdAt,
                updatedAt,
                comments,
                commentsData
              },
              files: {
                list: files.map(f => ({ filename: f.filename, additions: f.additions, deletions: f.deletions })),
                stats: { additions, deletions, changes }
              }
            };

      - name: Analyze and Apply Labels
        id: auto_labeler
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script-path: .github/scripts/classify.js
          github-token: ${{ github.token }}
          result-encoding: string
          inputs: |
            {
              "isPR": "${{ steps.extract_info.outputs.item_type }}" === "pull_request",
              "number": parseInt("${{ steps.extract_info.outputs.item_number }}", 10),
              "nodeId": "${{ steps.extract_info.outputs.node_id }}",
              "dryRun": "${{ github.event.inputs.dry_run }}" === "true",
              "areaOverride": "${{ github.event.inputs.area }}",
              "itemDetails": ${{ toJSON(steps.fetch_details.outputs.result) }}
            }

      - name: Create Classification Artifact
        id: create_artifact
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            
            // Get the classification results from the previous step
            const result = JSON.parse('${{ steps.auto_labeler.outputs.result }}');
            
            // Add metadata
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                updated_at: process.env.UPDATED_AT,
                version: process.env.WORKFLOW_VERSION,
                user: context.actor,
                event_type: context.eventName,
                action: context.payload.action || 'manual',
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`
              },
              ...result
            };
            
            // Ensure node_id is present
            if (!artifactData.item || !artifactData.item.node_id) {
              if ('${{ steps.extract_info.outputs.node_id }}') {
                if (!artifactData.item) artifactData.item = {};
                artifactData.item.node_id = '${{ steps.extract_info.outputs.node_id }}';
                core.info('📌 Added node_id from extract_info step to artifact');
              } else {
                core.warning('⚠️ No node_id available in classification or extract_info outputs');
              }
            }
            
            // Write to file
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            core.info('💾 Created classification artifact with the following data:');
            core.info(`- Item type: ${artifactData.item?.type || 'Unknown'}`);
            core.info(`- Item number: ${artifactData.item?.number || 'Unknown'}`);
            core.info(`- Node ID present: ${artifactData.item?.node_id ? 'Yes' : 'No'}`);
            
            core.setOutput('artifact_name', artifactName);
            
      - name: Upload Classification Artifact
        if: steps.extract_info.outputs.has_item == 'true' && steps.create_artifact.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 1

  # Step 2: Add to Project with classification data
  project_integration:
    name: "📋 Project Integration"
    needs: classify
    if: needs.classify.outputs.has_item == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: '.github'
      
      - name: Download Classification Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}
          
      - name: Debug Classification Data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              const data = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('📊 Classification Data Debug:');
              core.info(`- File exists: Yes`);
              core.info(`- Has metadata: ${data.metadata ? 'Yes' : 'No'}`);
              core.info(`- Has item: ${data.item ? 'Yes' : 'No'}`);
              
              if (data.item) {
                core.info(`- Item number: ${data.item.number || 'Not found'}`);
                core.info(`- Item type: ${data.item.type || 'Not found'}`);
                core.info(`- Node ID: ${data.item.node_id || 'Not found'}`);
              }
              
              if (!data.item?.node_id) {
                // Try to fetch node_id directly as fallback
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                const number = data.item?.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
                const isPR = data.item?.type === 'pull_request' || '${{ needs.classify.outputs.item_type }}' === 'pull_request';
                
                if (number) {
                  core.info(`🔄 Attempting to fetch node_id for ${isPR ? 'PR' : 'Issue'} #${number} as fallback...`);
                  
                  try {
                    if (isPR) {
                      const pr = await github.rest.pulls.get({owner, repo, pull_number: number});
                      data.item.node_id = pr.data.node_id;
                    } else {
                      const issue = await github.rest.issues.get({owner, repo, issue_number: number});
                      data.item.node_id = issue.data.node_id;
                    }
                    
                    if (data.item.node_id) {
                      core.info(`✅ Successfully retrieved node_id: ${data.item.node_id}`);
                      fs.writeFileSync('classification.json', JSON.stringify(data, null, 2));
                    }
                  } catch (e) {
                    core.warning(`❌ Failed to fetch node_id: ${e.message}`);
                  }
                }
              }
            } catch (e) {
              core.error(`❌ Failed to parse classification.json: ${e.message}`);
            }

      - name: Add to Project with Classification
        uses: actions/github-script@v7
        env:
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
          PROJECT_TITLE: ${{ github.event.inputs.project_title || env.DEFAULT_PROJECT_TITLE }}
          NODE_ID_FALLBACK: ${{ needs.classify.outputs.node_id }}
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN || github.token }}
          script-path: .github/scripts/project-integration.js
          inputs: |
            {
              "isDryRun": "${{ github.event.inputs.dry_run }}" === "true" || !process.env.GH_PROJECT_TOKEN,
              "projectTitle": process.env.PROJECT_TITLE,
              "nodeIdFallback": process.env.NODE_ID_FALLBACK,
              "itemNumber": parseInt("${{ needs.classify.outputs.item_number }}", 10),
              "itemType": "${{ needs.classify.outputs.item_type }}"
            }

      - name: Upload Integration Summary
        uses: actions/upload-artifact@v4
        with:
          name: project-integration-summary
          path: project-integration-summary.json
          retention-days: 7