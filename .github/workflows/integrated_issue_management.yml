name: Integrated Issue Management (Personal Account)

# Workflow that combines auto-labeling and project management
# Created: 2025-08-20
# Author: Andhika-Rey
# Version: 1.0.1

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      project_title:
        description: 'Project title to target'
        required: false
        default: "MerajutASA Program Board"
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  DEFAULT_PROJECT_TITLE: "MerajutASA Program Board"
  WORKFLOW_VERSION: "1.0.1"
  CREATED_AT: "2025-08-20"
  CREATED_BY: "Andhika-Rey"

jobs:
  # Step 1: Extract information and classify the issue/PR
  classify:
    name: "ðŸ” Extract & Classify"
    runs-on: ubuntu-latest
    outputs:
      item_number: ${{ steps.extract_info.outputs.item_number }}
      item_type: ${{ steps.extract_info.outputs.item_type }}
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      has_item: ${{ steps.extract_info.outputs.has_item }}
    
    steps:
      - name: Extract Item Information
        id: extract_info
        uses: actions/github-script@v7
        with:
          script: |
            const { eventName, payload, repo } = context;
            const owner = repo.owner;
            const repoName = repo.repo;
            
            let isPR = eventName === 'pull_request';
            let number = null;
            let hasItem = false;
            
            // Handle different event types to extract item number
            if (eventName === 'pull_request') {
              number = payload.pull_request.number;
              hasItem = true;
            } else if ((eventName === 'issues' || eventName === 'issue_comment') && payload.issue) {
              number = payload.issue.number;
              isPR = !!payload.issue.pull_request;
              hasItem = true;
            } else if (eventName === 'workflow_dispatch' && payload.inputs && payload.inputs.number) {
              number = parseInt(payload.inputs.number, 10);
              if (!isNaN(number)) {
                // Determine if number refers to a PR
                try {
                  await github.rest.pulls.get({
                    owner,
                    repo: repoName,
                    pull_number: number
                  });
                  isPR = true;
                  hasItem = true;
                } catch (e) {
                  try {
                    await github.rest.issues.get({
                      owner,
                      repo: repoName,
                      issue_number: number
                    });
                    isPR = false;
                    hasItem = true;
                  } catch (e) {
                    core.warning(`Item #${number} not found as issue or PR`);
                    hasItem = false;
                  }
                }
              }
            }
            
            if (hasItem) {
              core.info(`âœ… Found ${isPR ? 'PR' : 'Issue'} #${number}`);
            } else {
              core.warning('âš ï¸ No valid issue/PR number found in this event');
            }
            
            core.setOutput('item_number', number ? number.toString() : '');
            core.setOutput('item_type', isPR ? 'pull_request' : 'issue');
            core.setOutput('has_item', hasItem ? 'true' : 'false');

      # Skip the rest if no valid item was found
      - name: Check for valid item
        id: check_item
        if: steps.extract_info.outputs.has_item != 'true'
        run: |
          echo "::notice::No valid issue or PR found to process"
          exit 0

      - name: Analyze and Apply Labels
        id: auto_labeler
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
            const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            
            // Prevent relabel loops when the actor is the bot itself
            if ((context.eventName === 'issues' && ['labeled','unlabeled'].includes(context.payload.action)) ||
                (context.eventName === 'pull_request' && ['labeled','unlabeled'].includes(context.payload.action))) {
              if (context.actor === 'github-actions[bot]') {
                core.info('Skip to prevent relabel loop (actor is github-actions[bot]).');
                return { skipped: true, reason: 'bot_actor' };
              }
            }
            
            // Fetch latest item details
            let title = '', body = '', labels = [], milestoneTitle = '';
            let prState = null, isDraft = false, merged = false, issueState = null;
            let item = null;
            let nodeId = null;
            
            if (isPR) {
              const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
              item = pr;
              title = pr.title || '';
              body = pr.body || '';
              labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
              milestoneTitle = pr.milestone?.title || '';
              prState = typeof pr.state === 'string' ? pr.state.toLowerCase() : null;
              isDraft = !!pr.draft;
              merged = !!pr.merged;
              nodeId = pr.node_id; // Get the GraphQL node ID
            } else {
              const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
              item = issue;
              title = issue.title || '';
              body = issue.body || '';
              labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
              milestoneTitle = issue.milestone?.title || '';
              issueState = typeof issue.state === 'string' ? issue.state.toLowerCase() : null;
              nodeId = issue.node_id; // Get the GraphQL node ID
            }
            
            core.info(`Item GraphQL Node ID: ${nodeId}`);
            
            const existing = new Set(labels);
            
            // For PRs, gather changed files and stats
            let files = [], additions = 0, deletions = 0, changes = 0;
            if (isPR) {
              const perPage = 100;
              let page = 1;
              while (true) {
                const resp = await github.rest.pulls.listFiles({ 
                  owner, repo, pull_number: number, per_page: perPage, page 
                });
                files.push(...resp.data);
                if (resp.data.length < perPage) break;
                page += 1;
              }
              additions = files.reduce((s, f) => s + (f.additions || 0), 0);
              deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
              changes = files.reduce((s, f) => s + (f.changes || 0), 0);
            }
            
            const text = `${title}\n${body}`.toLowerCase();
            const filePaths = files.map(f => (f.filename || '').toLowerCase());
            
            // Heuristic classifiers
            const hasAny = (s, arr) => arr.some(k => s.includes(k));
            const pathHasAny = (arr) => filePaths.some(p => arr.some(k => p.includes(k)));
            
            // Area classification
            let area = null;
            if (pathHasAny(['auth', 'security', 'oauth', 'jwt', 'encryption']) || 
                hasAny(text, ['security', 'auth', 'csrf', 'xss'])) {
              area = 'area:security-layer';
            } else if (pathHasAny(['monitor', 'metrics', 'grafana', 'prometheus', 'logging', 'trace']) || 
                       hasAny(text, ['observability', 'monitoring', 'logging', 'tracing'])) {
              area = 'area:monitoring-observability';
            } else if (pathHasAny(['cache', 'optimization', 'perf', 'cdn', 'compression']) || 
                       hasAny(text, ['performance', 'optimiz', 'cache'])) {
              area = 'area:performance-optimization';
            } else if (pathHasAny(['k8s', 'kubernetes', 'helm', 'manifests', 'charts', 'docker']) || 
                       hasAny(text, ['container orchestration', 'kubernetes', 'helm'])) {
              area = 'area:container-orchestration';
            } else if (pathHasAny(['.github/workflows', 'deploy', 'pipeline', 'ci', 'cd']) || 
                       hasAny(text, ['ci/cd', 'pipeline', 'deployment'])) {
              area = 'area:cicd-pipeline';
            } else if (pathHasAny(['backup', 'migrations', 'db/', 'database', 'storage', 's3']) || 
                       hasAny(text, ['data management', 'backup'])) {
              area = 'area:data-management';
            } else if (pathHasAny(['api/', 'gateway', 'ingress', 'service', 'routes']) || 
                       hasAny(text, ['api gateway', 'service mesh', 'api'])) {
              area = 'area:api-gateway-services';
            } else if (!isPR && hasAny(text, ['doc', 'documentation']) || pathHasAny(['docs/'])) {
              area = 'area:docs';
            }
            
            // Risk classification
            let risk = null;
            const largeChange = changes > 500 || additions + deletions > 800;
            if (hasAny(text, ['breaking change', 'critical', 'security', 'vulnerability', 'hotfix']) || 
                largeChange) {
              risk = 'risk:high';
            } else if (hasAny(text, ['refactor', 'migration', 'upgrade']) || (changes > 100)) {
              risk = 'risk:medium';
            } else {
              risk = 'risk:low';
            }
            
            // Status label (for issues/PRs)
            let status = null;
            if (isPR) {
              if (merged) {
                status = 'status:done';
              } else if (prState === 'closed') {
                status = 'status:done';
              } else if (context.payload.action === 'ready_for_review' || !isDraft) {
                status = 'status:in-review';
              } else {
                status = 'status:in-progress';
              }
            } else {
              if (issueState === 'closed') {
                status = 'status:done';
              } else if (hasAny(text, ['wip', 'progress'])) {
                status = 'status:in-progress';
              } else {
                status = 'status:todo';
              }
            }
            
            // Team assignment by area
            let team = null;
            if (area === 'area:security-layer') {
              team = 'team:security';
            } else if (area === 'area:cicd-pipeline' || area === 'area:container-orchestration') {
              team = 'team:devops';
            } else if (area === 'area:monitoring-observability') {
              team = 'team:qa';
            } else {
              team = 'team:backend-dev';
            }
            
            // Implementation size from change set
            let size = null;
            const total = additions + deletions;
            if (total <= 100) {
              size = 'size:small';
            } else if (total <= 250) {
              size = 'size:medium';
            } else if (total <= 500) {
              size = 'size:large';
            } else if (total <= 1000) {
              size = 'size:very-large';
            } else if (total <= 2000) {
              size = 'size:enterprise';
            } else {
              size = 'size:system';
            }
            
            // Health score heuristic (basic): tests/docs present increase score
            let health = 'health:50-74';
            const hasTests = pathHasAny(['test', 'spec']);
            const hasDocs = pathHasAny(['docs/', 'readme']);
            const thorough = hasTests && hasDocs && !largeChange;
            if (thorough) {
              health = 'health:90-99';
            } else if (hasTests || hasDocs) {
              health = 'health:75-89';
            } else if (largeChange) {
              health = 'health:25-49';
            }
            
            // Iteration from milestone or title/body
            let iteration = null;
            const iterMatch = (milestoneTitle || text).match(/sprint[-\s]?(\d+)/i);
            if (iterMatch) {
              iteration = `iteration:sprint-${iterMatch[1]}`;
            } else if (hasAny(text, ['maintenance'])) {
              iteration = 'iteration:maintenance';
            } else if (hasAny(text, ['research', 'spike'])) {
              iteration = 'iteration:research';
            }
            
            // Build label sets (single-choice categories)
            const singleChoiceSets = {
              risk: ['risk:low','risk:medium','risk:high'],
              status: ['status:todo','status:in-progress','status:in-review','status:blocked','status:done'],
              size: ['size:small','size:medium','size:large','size:very-large','size:enterprise','size:system'],
              health: ['health:100','health:90-99','health:75-89','health:50-74','health:25-49','health:0-24'],
              iteration: ['iteration:sprint-1','iteration:sprint-2','iteration:sprint-3','iteration:sprint-4',
                         'iteration:sprint-5','iteration:sprint-6','iteration:epic','iteration:maintenance',
                         'iteration:research']
            };
            
            const toAdd = new Set();
            const toRemove = new Set();
            
            function setSingleChoice(target) {
              if (!target) return;
              for (const [_, set] of Object.entries(singleChoiceSets)) {
                if (set.includes(target)) {
                  set.forEach(l => { if (existing.has(l) && l !== target) toRemove.add(l); });
                }
              }
              if (!existing.has(target)) toAdd.add(target);
            }
            
            // Apply choices
            setSingleChoice(risk);
            setSingleChoice(status);
            setSingleChoice(size);
            setSingleChoice(health);
            setSingleChoice(iteration);
            if (area && !existing.has(area)) toAdd.add(area);
            if (team && !existing.has(team)) toAdd.add(team);
            
            const addList = Array.from(toAdd);
            const removeList = Array.from(toRemove);
            
            // Record classifications for next step
            const classifications = {
              area: area ? { value: area.split(':')[1], source: 'heuristic' } : null,
              risk: risk ? { value: risk.split(':')[1], source: 'heuristic' } : null,
              status: status ? { value: status.split(':')[1], source: 'heuristic' } : null,
              team: team ? { value: team.split(':')[1], source: 'heuristic' } : null,
              size: size ? { value: size.split(':')[1], source: 'heuristic' } : null,
              health: health ? { value: health.split(':')[1], source: 'heuristic' } : null,
              iteration: iteration ? { value: iteration.split(':')[1], source: 'heuristic' } : null
            };
            
            // Dry-run log
            if (dryRun) {
              core.info('ðŸ§ª DRY RUN: Label changes preview');
              core.info(`Would add: ${addList.join(', ') || 'None'}`);
              core.info(`Would remove: ${removeList.join(', ') || 'None'}`);
              return {
                dryRun: true,
                item: {
                  type: isPR ? 'pull_request' : 'issue',
                  number: number,
                  title: title,
                  url: item.html_url,
                  node_id: nodeId  // Include the GraphQL node ID
                },
                labels: {
                  existing: Array.from(existing),
                  toAdd: addList,
                  toRemove: removeList
                },
                classifications: classifications,
                stats: { additions, deletions, changes }
              };
            }
            
            // Apply removals first
            for (const l of removeList) {
              try {
                await github.rest.issues.removeLabel({ 
                  owner, repo, issue_number: number, name: l 
                });
                core.info(`Removed label: ${l}`);
              } catch (e) {
                if (e.status !== 404) core.warning(`Failed to remove label ${l}: ${e.message}`);
              }
            }
            
            // Apply additions
            if (addList.length) {
              try {
                await github.rest.issues.addLabels({ 
                  owner, repo, issue_number: number, labels: addList 
                });
                core.info(`Added labels: ${addList.join(', ')}`);
              } catch (e) {
                core.warning(`Failed to add labels: ${e.message}`);
              }
            } else {
              core.info('No labels to add');
            }
            
            // Return final state for artifact
            const finalLabels = [...labels.filter(l => !removeList.includes(l)), ...addList];
            
            return {
              item: {
                type: isPR ? 'pull_request' : 'issue',
                number: number,
                title: title,
                body: body,
                url: item.html_url,
                state: isPR ? prState : issueState,
                isPR: isPR,
                isDraft: isDraft,
                merged: merged,
                node_id: nodeId  // Include the GraphQL node ID
              },
              labels: {
                final: finalLabels,
                added: addList,
                removed: removeList
              },
              classifications: classifications,
              stats: { additions, deletions, changes },
              files: files.map(f => ({ 
                filename: f.filename, 
                additions: f.additions, 
                deletions: f.deletions 
              }))
            };

      - name: Create Classification Artifact
        id: create_artifact
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            
            // Get the classification results from the previous step
            const result = ${{ toJSON(steps.auto_labeler.outputs.result) }};
            
            // Add metadata
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                version: process.env.WORKFLOW_VERSION,
                user: context.actor,
                event_type: context.eventName,
                action: context.payload.action || 'manual',
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`
              },
              ...result
            };
            
            // Write to file
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            
            core.setOutput('artifact_name', artifactName);
            
      - name: Upload Classification Artifact
        if: steps.extract_info.outputs.has_item == 'true' && steps.create_artifact.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 1

  # Step 2: Add to Project with classification data
  project_integration:
    name: "ðŸ“‹ Project Integration"
    needs: classify
    if: needs.classify.outputs.has_item == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Classification Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}
          
      - name: Add to Project with Classification
        uses: actions/github-script@v7
        env:
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
          PROJECT_TITLE: ${{ github.event.inputs.project_title || env.DEFAULT_PROJECT_TITLE }}
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const hasPat = !!(process.env.GH_PROJECT_TOKEN && process.env.GH_PROJECT_TOKEN.trim());
            const isDryRun = !hasPat || '${{ github.event.inputs.dry_run }}' === 'true';
            
            // Load classification data
            let classification;
            try {
              classification = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('âœ… Loaded classification data');
            } catch (e) {
              core.setFailed(`Failed to load classification data: ${e.message}`);
              return;
            }
            
            // Extract key information
            const metadata = classification.metadata || {};
            const item = classification.item || {};
            const classifications = classification.classifications || {};
            const labels = classification.labels?.final || [];
            
            const itemType = item.type || '${{ needs.classify.outputs.item_type }}';
            const itemNumber = item.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
            const isPR = itemType === 'pull_request';
            const contentId = item.node_id; // Get the GraphQL node ID from classification
            
            if (!contentId) {
              core.setFailed('Missing node_id in classification data. Cannot add to project.');
              return;
            }
            
            // Project configuration
            const ownerLogin = context.repo.owner;
            const projectTitle = process.env.PROJECT_TITLE || 'MerajutASA Program Board';
            
            core.info(`ðŸŽ¯ Processing ${isPR ? 'PR' : 'Issue'} #${itemNumber} for project "${projectTitle}"`);
            core.info(`Using node ID: ${contentId}`);
            
            if (isDryRun) {
              core.info('ðŸ§ª DRY RUN MODE: Will simulate but not make actual changes');
              if (!hasPat) {
                core.info('âš ï¸ No PAT provided, cannot make GraphQL queries to Projects V2 API');
              }
            }
            
            // Project lookup
            let project;
            try {
              if (isDryRun && !hasPat) {
                core.info('ðŸ§ª DRY RUN: Would look up project');
                project = { id: 'dry-run-project-id', title: projectTitle, url: 'https://github.com/users/Andhika-Rey/projects/1' };
              } else {
                const projectQuery = `
                  query($owner: String!) {
                    repositoryOwner(login: $owner) {
                      id
                      login
                      ... on User {
                        projectsV2(first: 20) {
                          nodes {
                            id title url public
                            fields(first: 50) {
                              nodes {
                                __typename
                                ... on ProjectV2FieldCommon { id name dataType }
                                ... on ProjectV2SingleSelectField { 
                                  id name dataType 
                                  options { id name color description } 
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                const resp = await github.graphql(projectQuery, { owner: ownerLogin });
                const nodes = resp.repositoryOwner?.projectsV2?.nodes || [];
                
                project = nodes.find(p => p.title === projectTitle)
                      || nodes.find(p => p.title.toLowerCase() === projectTitle.toLowerCase())
                      || nodes.find(p => p.title === 'MerajutASA Program Board');
                      
                if (!project) {
                  core.warning(`âŒ Project "${projectTitle}" not found in ${ownerLogin}'s account`);
                  core.info('ðŸ’¡ Available projects:');
                  for (const p of nodes) {
                    core.info(`- ${p.title}`);
                  }
                  return;
                }
              }
            } catch (error) {
              core.warning(`âŒ Project lookup failed: ${error.message}`);
              return;
            }
            
            core.info(`âœ… Using project: ${project.title} (${project.url || 'N/A'})`);
            
            const projectId = project.id;
            const fields = isDryRun && !hasPat ? [] : (project.fields?.nodes || []);
            
            // Helper functions for field operations
            function getField(name) { 
              return fields.find(f => f.name === name); 
            }
            
            async function setSingleSelect(fieldName, optionName) {
              const field = getField(fieldName);
              if (!field || field.dataType !== 'SINGLE_SELECT') {
                core.info(`âš ï¸ Field "${fieldName}" not found or not a single select field`);
                return false;
              }
              
              const option = (field.options || []).find(o => 
                o.name.toLowerCase() === optionName.toLowerCase()
              );
              
              if (!option) {
                core.info(`âš ï¸ Option "${optionName}" not found for field "${fieldName}"`);
                core.info(`Available options: ${(field.options || []).map(o => o.name).join(', ')}`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`ðŸ§ª DRY RUN: Would set ${fieldName} = ${optionName}`);
                return true; 
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  optionId: option.id 
                });
                core.info(`âœ… Set ${fieldName} = ${optionName}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            async function setDate(fieldName, value) {
              const field = getField(fieldName);
              if (!field || field.dataType !== 'DATE') {
                core.info(`âš ï¸ Field "${fieldName}" not found or not a date field`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`ðŸ§ª DRY RUN: Would set ${fieldName} = ${value}`);
                return true;
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: Date!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { date: $v }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  v: value 
                });
                core.info(`âœ… Set ${fieldName} = ${value}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            async function setNumber(fieldName, value) {
              const field = getField(fieldName);
              if (!field || field.dataType !== 'NUMBER') {
                core.info(`âš ï¸ Field "${fieldName}" not found or not a number field`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`ðŸ§ª DRY RUN: Would set ${fieldName} = ${value}`);
                return true;
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: Float!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId, 
                      value: { number: $v }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  v: value 
                });
                core.info(`âœ… Set ${fieldName} = ${value}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            async function setText(fieldName, value, options = {}) {
              const { overwrite = true } = options;
              
              if (!value || !String(value).trim()) {
                if (!overwrite) {
                  core.info(`Skipping empty text value for ${fieldName} (overwrite=false)`);
                  return false;
                }
              }
              
              const field = getField(fieldName);
              if (!field || field.dataType !== 'TEXT') {
                core.info(`âš ï¸ Field "${fieldName}" not found or not a text field`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`ðŸ§ª DRY RUN: Would set ${fieldName} = ${value}`);
                return true;
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { text: $v }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  v: value 
                });
                core.info(`âœ… Set ${fieldName} = ${value}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            // Ensure item exists in project or add it
            let itemId;
            if (isDryRun && !hasPat) {
              core.info('ðŸ§ª DRY RUN: Would check if item exists in project');
              itemId = 'dry-run-item-id';
            } else {
              // First, check if item already exists
              const itemQuery = `
                query($projectId: ID!, $first: Int = 100) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: $first) {
                        nodes {
                          id
                          content {
                            ... on Issue { id number repository { nameWithOwner } }
                            ... on PullRequest { id number repository { nameWithOwner } }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const itemsResp = await github.graphql(itemQuery, { projectId });
              const items = itemsResp.node.items.nodes;
              
              const repoFullName = `${context.repo.owner}/${context.repo.repo}`;
              const existingItem = items.find(i => 
                i.content && 
                i.content.number === itemNumber && 
                i.content.repository?.nameWithOwner === repoFullName
              );
              
              if (existingItem) {
                itemId = existingItem.id;
                core.info(`ðŸ”„ Item already exists in project, ID: ${itemId}`);
              } else {
                // Add item to project
                core.info(`âž• Adding ${isPR ? 'PR' : 'Issue'} #${itemNumber} to project`);
                
                try {
                  const addMutation = `
                    mutation($projectId: ID!, $contentId: ID!) { 
                      addProjectV2ItemById(input: {
                        projectId: $projectId, 
                        contentId: $contentId
                      }) { 
                        item { id } 
                      } 
                    }
                  `;
                  
                  const addResult = await github.graphql(addMutation, { 
                    projectId, 
                    contentId 
                  });
                  
                  itemId = addResult.addProjectV2ItemById.item.id;
                  core.info(`âœ… Added item with ID: ${itemId}`);
                } catch (e) {
                  core.setFailed(`Failed to add item to project: ${e.message}`);
                  return;
                }
              }
            }
            
            // Apply field mappings based on classification results
            const results = [];
            
            // Map classifications to project fields
            if (classifications.area?.value) {
              const areaKey = classifications.area.value;
              const areaMapping = { 
                'security-layer': 'Security Layer', 
                'monitoring-observability': 'Monitoring & Observability', 
                'performance-optimization': 'Performance Optimization', 
                'container-orchestration': 'Container Orchestration',
                'cicd-pipeline': 'CI/CD Pipeline',
                'data-management': 'Data Management',
                'api-gateway-services': 'API Gateway & Services',
                'docs': 'Documentation'
              };
              const mappedArea = areaMapping[areaKey] || areaKey.replace(/-/g, ' ');
              results.push(await setSingleSelect('Area', mappedArea));
            }
            
            if (classifications.risk?.value) {
              const riskMapping = {
                'low': 'Low', 
                'medium': 'Medium', 
                'high': 'High'
              };
              results.push(await setSingleSelect('Risk', riskMapping[classifications.risk.value] || 'Medium'));
            }
            
            if (classifications.status?.value) {
              const statusMapping = {
                'todo': 'To Do',
                'in-progress': 'In Progress',
                'in-review': 'In Review',
                'blocked': 'Blocked',
                'done': 'Done'
              };
              results.push(await setSingleSelect('Status', statusMapping[classifications.status.value] || 'To Do'));
            }
            
            if (classifications.team?.value) {
              const teamValue = classifications.team.value.replace(/-/g, ' ');
              results.push(await setSingleSelect('Team Assignment', teamValue));
            }
            
            if (classifications.size?.value) {
              const sizeMapping = {
                'small': '< 10KB',
                'medium': '10-25KB',
                'large': '25-50KB',
                'very-large': '50-100KB',
                'enterprise': '100KB+',
                'system': 'Enterprise Scale'
              };
              results.push(await setSingleSelect('Implementation Size', sizeMapping[classifications.size.value] || classifications.size.value));
            }
            
            if (classifications.health?.value) {
              const healthMapping = {
                '100': '100/100',
                '90-99': '90-99/100',
                '75-89': '75-89/100',
                '50-74': '50-74/100',
                '25-49': '25-49/100',
                '0-24': '0-24/100'
              };
              results.push(await setSingleSelect('Health Score', healthMapping[classifications.health.value] || classifications.health.value));
            }
            
            if (classifications.iteration?.value) {
              const iterValue = classifications.iteration.value.replace(/-/g, ' ');
              results.push(await setSingleSelect('Iteration', iterValue));
            }
            
            // Process labels for additional fields
            const labelSet = new Set(labels || []);
            
            // Phase from labels
            const phaseLabel = Array.from(labelSet).find(l => l.toLowerCase().startsWith('phase:'));
            if (phaseLabel) {
              const raw = phaseLabel.slice('phase:'.length).toLowerCase();
              const phaseMapping = {
                '1': 'Phase 1',
                '2-week-1': 'Phase 2 W1',
                '2-week-2': 'Phase 2 W2',
                '2-week-3': 'Phase 2 W3',
                '2-week-4': 'Phase 2 W4',
                '2-week-5': 'Phase 2 W5',
                '2-week-6': 'Phase 2 W6',
                '2-week-7': 'Phase 2 W7',
                '2-week-8': 'Phase 2 W8',
                '3-q1': 'Phase 3 Q1',
                '3-q2': 'Phase 3 Q2',
                '3-q3': 'Phase 3 Q3',
                '3-q4': 'Phase 3 Q4'
              };
              const target = phaseMapping[raw];
              if (target) results.push(await setSingleSelect('Phase', target));
            }
            
            // Dates from labels
            const startDateLabel = Array.from(labelSet).find(l => l.startsWith('start:'));
            if (startDateLabel) {
              const dateStr = startDateLabel.slice('start:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                results.push(await setDate('Start date', dateStr));
              }
            }
            
            const dueDateLabel = Array.from(labelSet).find(l => l.startsWith('due:'));
            if (dueDateLabel) {
              const dateStr = dueDateLabel.slice('due:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                results.push(await setDate('Target date', dateStr));
              }
            }
            
            // Estimate from labels
            const estimateLabel = Array.from(labelSet).find(l => l.startsWith('est:h:'));
            if (estimateLabel) {
              const hours = parseFloat(estimateLabel.slice('est:h:'.length));
              if (!isNaN(hours) && hours > 0) {
                results.push(await setNumber('Estimate (h)', hours));
              }
            }
            
            // Owner from original classification data
            if (item.assignees && item.assignees.length > 0) {
              results.push(await setText('Owner (text)', item.assignees[0]));
            } else if (item.author) {
              results.push(await setText('Owner (text)', item.author, { overwrite: false }));
            }
            
            // Links from body
            const urlMatch = (item.body || '').match(/https?:\/\/\S+/);
            if (urlMatch) {
              results.push(await setText('Links', urlMatch[0], { overwrite: false }));
            }
            
            // Milestone
            if (item.milestone?.title) {
              results.push(await setText('Milestone', item.milestone.title));
            }
            
            // Write integration summary
            const summary = {
              metadata: metadata,
              project: {
                title: project.title,
                url: project.url || '',
                owner: ownerLogin
              },
              item: {
                type: itemType,
                number: itemNumber,
                title: item.title,
                added_to_project: !isDryRun
              },
              fields_updated: results.filter(Boolean).length,
              dry_run: isDryRun,
              timestamp: new Date().toISOString()
            };
            
            core.info('ðŸ“Š Project integration complete');
            if (isDryRun) {
              core.info('ðŸ§ª This was a dry run - no actual changes were made');
            } else {
              core.info(`âœ… Successfully added to project and updated ${results.filter(Boolean).length} fields`);
            }
            
            // Write summary for artifact
            try {
              fs.writeFileSync('project-integration-summary.json', JSON.stringify(summary, null, 2));
            } catch (e) {
              core.warning(`Failed to write summary: ${e.message}`);
            }

      - name: Upload Integration Summary
        uses: actions/upload-artifact@v4
        with:
          name: project-integration-summary
          path: project-integration-summary.json
          retention-days: 7