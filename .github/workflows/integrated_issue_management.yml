name: Integrated Issue Management (Personal Account)

# Workflow that combines auto-labeling and project management
# Created: 2025-08-20
# Author: Andhika-Rey
# Version: 1.1.0

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      project_title:
        description: 'Project title to target'
        required: false
        default: "MerajutASA Program Board"
      area:
        description: 'Override area classification'
        required: false
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  DEFAULT_PROJECT_TITLE: "MerajutASA Program Board"
  WORKFLOW_VERSION: "1.1.0"
  CREATED_AT: "2025-08-20"
  UPDATED_AT: "2025-08-20 04:17:20"
  CREATED_BY: "Andhika-Rey"

jobs:
  # Step 1: Extract information and classify the issue/PR
  classify:
    name: "üîç Extract & Classify"
    runs-on: ubuntu-latest
    outputs:
      item_number: ${{ steps.extract_info.outputs.item_number }}
      item_type: ${{ steps.extract_info.outputs.item_type }}
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      has_item: ${{ steps.extract_info.outputs.has_item }}
      node_id: ${{ steps.extract_info.outputs.node_id }}
    
    steps:
      - name: Extract Item Information
        id: extract_info
        uses: actions/github-script@v7
        with:
          script: |
            const { eventName, payload, repo } = context;
            const owner = repo.owner;
            const repoName = repo.repo;
            
            let isPR = eventName === 'pull_request';
            let number = null;
            let hasItem = false;
            let nodeId = null;
            
            // Handle different event types to extract item number
            if (eventName === 'pull_request') {
              number = payload.pull_request.number;
              nodeId = payload.pull_request.node_id;
              hasItem = true;
            } else if ((eventName === 'issues' || eventName === 'issue_comment') && payload.issue) {
              number = payload.issue.number;
              nodeId = payload.issue.node_id;
              isPR = !!payload.issue.pull_request;
              hasItem = true;
            } else if (eventName === 'workflow_dispatch' && payload.inputs && payload.inputs.number) {
              number = parseInt(payload.inputs.number, 10);
              if (!isNaN(number)) {
                // Determine if number refers to a PR
                try {
                  const pr = await github.rest.pulls.get({
                    owner,
                    repo: repoName,
                    pull_number: number
                  });
                  isPR = true;
                  nodeId = pr.data.node_id;
                  hasItem = true;
                } catch (e) {
                  try {
                    const issue = await github.rest.issues.get({
                      owner,
                      repo: repoName,
                      issue_number: number
                    });
                    isPR = false;
                    nodeId = issue.data.node_id;
                    hasItem = true;
                  } catch (e) {
                    core.warning(`Item #${number} not found as issue or PR`);
                    hasItem = false;
                  }
                }
              }
            }
            
            if (hasItem) {
              core.info(`‚úÖ Found ${isPR ? 'PR' : 'Issue'} #${number}`);
              if (nodeId) {
                core.info(`üìå Node ID: ${nodeId}`);
              } else {
                core.warning('‚ö†Ô∏è No Node ID found, will try to fetch it in next step');
              }
            } else {
              core.warning('‚ö†Ô∏è No valid issue/PR number found in this event');
            }
            
            core.setOutput('item_number', number ? number.toString() : '');
            core.setOutput('item_type', isPR ? 'pull_request' : 'issue');
            core.setOutput('has_item', hasItem ? 'true' : 'false');
            if (nodeId) {
              core.setOutput('node_id', nodeId);
            }

      # Skip the rest if no valid item was found
      - name: Check for valid item
        id: check_item
        if: steps.extract_info.outputs.has_item != 'true'
        run: |
          echo "::notice::No valid issue or PR found to process"
          exit 0

      - name: Analyze and Apply Labels
        id: auto_labeler
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
            const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            const areaOverride = '${{ github.event.inputs.area }}' || null;
            
            // Prevent relabel loops when the actor is the bot itself
            if ((context.eventName === 'issues' && ['labeled','unlabeled'].includes(context.payload.action)) ||
                (context.eventName === 'pull_request' && ['labeled','unlabeled'].includes(context.payload.action))) {
              if (context.actor === 'github-actions[bot]') {
                core.info('Skip to prevent relabel loop (actor is github-actions[bot]).');
                return { skipped: true, reason: 'bot_actor' };
              }
            }
            
            // Fetch latest item details
            let title = '', body = '', labels = [], milestoneTitle = '';
            let prState = null, isDraft = false, merged = false, issueState = null;
            let item = null;
            let nodeId = '${{ steps.extract_info.outputs.node_id }}';
            let assignees = [], comments = 0, commentsData = [];
            let createdAt, updatedAt;
            let author = null;
            
            // Get full issue/PR data including comments
            try {
              if (isPR) {
                const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                item = pr;
                title = pr.title || '';
                body = pr.body || '';
                labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = pr.milestone?.title || '';
                prState = typeof pr.state === 'string' ? pr.state.toLowerCase() : null;
                isDraft = !!pr.draft;
                merged = !!pr.merged;
                if (!nodeId) nodeId = pr.node_id;
                assignees = pr.assignees?.map(a => a.login) || [];
                author = pr.user?.login;
                createdAt = pr.created_at;
                updatedAt = pr.updated_at;
                
                // Get PR comments
                const prComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = prComments.data.length;
                commentsData = prComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                }));
                
                // Get PR review comments
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner, repo, pull_number: number, per_page: 100
                });
                comments += reviewComments.data.length;
                commentsData.push(...reviewComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                })));
              } else {
                const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                item = issue;
                title = issue.title || '';
                body = issue.body || '';
                labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = issue.milestone?.title || '';
                issueState = typeof issue.state === 'string' ? issue.state.toLowerCase() : null;
                if (!nodeId) nodeId = issue.node_id;
                assignees = issue.assignees?.map(a => a.login) || [];
                author = issue.user?.login;
                createdAt = issue.created_at;
                updatedAt = issue.updated_at;
                
                // Get issue comments
                const issueComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = issueComments.data.length;
                commentsData = issueComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login, 
                  created_at: c.created_at
                }));
              }
              
              core.info(`üìù Title: ${title}`);
              core.info(`üë§ Author: ${author || 'Unknown'}`);
              core.info(`üí¨ Comments: ${comments}`);
              core.info(`üìÖ Created: ${createdAt}`);
            } catch (e) {
              core.warning(`‚ö†Ô∏è Error fetching details: ${e.message}`);
            }
            
            if (!nodeId) {
              core.warning('‚ùå Could not determine Node ID, project integration may fail');
            } else {
              core.info(`üìå Item GraphQL Node ID: ${nodeId}`);
            }
            
            const existing = new Set(labels);
            
            // For PRs, gather changed files and stats
            let files = [], additions = 0, deletions = 0, changes = 0;
            if (isPR) {
              const perPage = 100;
              let page = 1;
              while (true) {
                try {
                  const resp = await github.rest.pulls.listFiles({ 
                    owner, repo, pull_number: number, per_page: perPage, page 
                  });
                  files.push(...resp.data);
                  if (resp.data.length < perPage) break;
                  page += 1;
                } catch (e) {
                  core.warning(`Failed to get PR files page ${page}: ${e.message}`);
                  break;
                }
              }
              additions = files.reduce((s, f) => s + (f.additions || 0), 0);
              deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
              changes = files.reduce((s, f) => s + (f.changes || 0), 0);
              core.info(`üìä PR Stats: +${additions} -${deletions} changes: ${changes}`);
            }
            
            // Enhanced content analysis with multiple approaches
            const allContent = [
              title,
              body,
              ...commentsData.map(c => c.body)
            ].filter(Boolean).join('\n').toLowerCase();
            
            const filePaths = files.map(f => (f.filename || '').toLowerCase());
            
            // Define word lists for better classification
            const securityTerms = ['security', 'auth', 'authentication', 'authorization', 'login', 'password', 'credential', 'oauth', 'jwt', 'token', 'encryption', 'decrypt', 'csrf', 'xss', 'injection', 'vulnerability', 'exploit', 'attack', 'firewall', 'ssl', 'tls', 'https', 'certificate'];
            
            const monitoringTerms = ['monitor', 'metrics', 'grafana', 'prometheus', 'logging', 'trace', 'observability', 'analytics', 'alert', 'dashboard', 'telemetry', 'apm', 'uptime', 'health check', 'sentry', 'datadog', 'newrelic', 'log4j', 'elasticsearch', 'kibana', 'splunk', 'nagios'];
            
            const performanceTerms = ['performance', 'optimize', 'optimization', 'speed', 'fast', 'slow', 'latency', 'throughput', 'bottleneck', 'cache', 'cdn', 'compression', 'gzip', 'minify', 'lazy load', 'preload', 'prefetch', 'benchmark', 'profile', 'memory leak', 'cpu usage', 'response time', 'p95', 'p99', 'ttfb'];
            
            const containerTerms = ['kubernetes', 'k8s', 'container', 'docker', 'pod', 'cluster', 'orchestration', 'helm', 'chart', 'manifest', 'deployment', 'statefulset', 'configmap', 'ingress', 'service mesh', 'istio', 'linkerd', 'kustomize', 'argo'];
            
            const cicdTerms = ['ci', 'cd', 'continuous integration', 'continuous delivery', 'pipeline', 'github actions', 'jenkins', 'travis', 'gitlab', 'build', 'deploy', 'release', 'workflow', 'automation', 'devops', 'gitops', 'artifact'];
            
            const dataTerms = ['database', 'db', 'sql', 'nosql', 'mongodb', 'postgres', 'mysql', 'redis', 'migration', 'schema', 'backup', 'restore', 'data model', 'orm', 'query', 'index', 'shard', 'replica', 'etl', 's3', 'storage', 'blob'];
            
            const apiTerms = ['api', 'rest', 'graphql', 'endpoint', 'gateway', 'service', 'microservice', 'route', 'path', 'http', 'request', 'response', 'status code', 'header', 'parameter', 'swagger', 'openapi', 'grpc', 'websocket', 'webhook'];
            
            const docsTerms = ['documentation', 'doc', 'readme', 'wiki', 'guide', 'tutorial', 'manual', 'instruction', 'how-to', 'example', 'reference', 'api doc', 'swagger', 'javadoc', 'jsdoc', 'comment'];
            
            const uiTerms = ['ui', 'ux', 'user interface', 'design', 'layout', 'css', 'html', 'front-end', 'frontend', 'react', 'vue', 'angular', 'component', 'accessibility', 'responsive', 'mobile', 'desktop'];
            
            // Helper functions for NLP-like classification
            function countTerms(text, termList) {
              if (!text) return 0;
              let count = 0;
              for (const term of termList) {
                const regex = new RegExp('\\b' + term + '\\b', 'gi');
                const matches = text.match(regex);
                count += matches ? matches.length : 0;
              }
              return count;
            }
            
            function confidenceScore(count, threshold = 2) {
              if (count === 0) return 0;
              if (count === 1) return 0.5;
              if (count <= threshold) return 0.75;
              return 0.9 + Math.min(0.09, (count - threshold) * 0.01);
            }
            
            // Enhanced heuristic classifiers
            const hasAny = (s, arr) => arr.some(k => s.includes(k));
            const pathHasAny = (arr) => filePaths.some(p => arr.some(k => p.includes(k)));
            
            // Advanced area classification with confidence scores
            let areaScores = {
              'security-layer': confidenceScore(
                countTerms(allContent, securityTerms) + 
                (pathHasAny(['auth', 'security', 'oauth', 'jwt', 'encryption', 'passport', 'login']) ? 3 : 0)
              ),
              'monitoring-observability': confidenceScore(
                countTerms(allContent, monitoringTerms) + 
                (pathHasAny(['monitor', 'metrics', 'grafana', 'prometheus', 'logging', 'trace']) ? 3 : 0)
              ),
              'performance-optimization': confidenceScore(
                countTerms(allContent, performanceTerms) + 
                (pathHasAny(['cache', 'optimization', 'perf', 'cdn', 'compression']) ? 3 : 0)
              ),
              'container-orchestration': confidenceScore(
                countTerms(allContent, containerTerms) + 
                (pathHasAny(['k8s', 'kubernetes', 'helm', 'manifests', 'charts', 'docker']) ? 3 : 0)
              ),
              'cicd-pipeline': confidenceScore(
                countTerms(allContent, cicdTerms) + 
                (pathHasAny(['.github/workflows', 'deploy', 'pipeline', 'ci', 'cd', '.gitlab-ci', 'jenkins']) ? 3 : 0)
              ),
              'data-management': confidenceScore(
                countTerms(allContent, dataTerms) + 
                (pathHasAny(['backup', 'migrations', 'db/', 'database', 'storage', 's3', 'mongo', 'sql']) ? 3 : 0)
              ),
              'api-gateway-services': confidenceScore(
                countTerms(allContent, apiTerms) + 
                (pathHasAny(['api/', 'gateway', 'ingress', 'service', 'routes', 'controller']) ? 3 : 0)
              ),
              'docs': confidenceScore(
                countTerms(allContent, docsTerms) + 
                (pathHasAny(['docs/', 'documentation', 'wiki', 'readme', '.md']) ? 3 : 0)
              ),
              'ui-components': confidenceScore(
                countTerms(allContent, uiTerms) + 
                (pathHasAny(['ui/', 'components', 'css', 'html', 'jsx', 'tsx', 'vue', 'react']) ? 3 : 0)
              )
            };
            
            // Find the area with highest score
            let bestArea = null;
            let bestScore = 0.3; // Minimum threshold to assign area
            
            for (const [area, score] of Object.entries(areaScores)) {
              if (score > bestScore) {
                bestArea = area;
                bestScore = score;
              }
            }
            
            // Special handling for very short issues/PRs
            const minimalContent = title.length + (body?.length || 0) < 20;
            if (minimalContent) {
              core.info('‚ö†Ô∏è Minimal content detected, using enhanced classification');
              
              // For test issues/PRs, assume it's for testing and QA
              if (title.toLowerCase().includes('test') && (!body || body.length < 20)) {
                bestArea = 'monitoring-observability'; // QA related
                bestScore = 0.6;
                core.info('‚úÖ Test-related issue/PR detected, classified as monitoring-observability');
              }
              
              // Use file patterns as stronger signal for minimal PRs
              if (isPR && files.length > 0) {
                // Re-evaluate based more heavily on files than content
                const fileTypes = files.reduce((types, file) => {
                  const ext = file.filename.split('.').pop().toLowerCase();
                  types[ext] = (types[ext] || 0) + 1;
                  return types;
                }, {});
                
                // Log file type distribution
                core.info(`üìÇ File types: ${JSON.stringify(fileTypes)}`);
                
                if (fileTypes.md || fileTypes.txt || fileTypes.rst) {
                  bestArea = 'docs';
                  bestScore = Math.max(bestScore, 0.7);
                } else if (fileTypes.js || fileTypes.ts || fileTypes.jsx || fileTypes.tsx || fileTypes.vue) {
                  bestArea = fileTypes.vue || fileTypes.jsx || fileTypes.tsx ? 'ui-components' : 'api-gateway-services';
                  bestScore = Math.max(bestScore, 0.6);
                } else if (fileTypes.yml || fileTypes.yaml) {
                  bestArea = 'cicd-pipeline';
                  bestScore = Math.max(bestScore, 0.7);
                } else if (fileTypes.sql || fileTypes.py || fileTypes.rb) {
                  bestArea = 'data-management';
                  bestScore = Math.max(bestScore, 0.6);
                } else if (fileTypes.java || fileTypes.go || fileTypes.cs) {
                  bestArea = 'api-gateway-services';
                  bestScore = Math.max(bestScore, 0.5);
                }
              }
              
              // Look at other signals
              if (assignees.length > 0) {
                // Assignee-based hints (sample logic - would need real team data)
                const securityTeam = ['securitydev1', 'securitydev2'];
                const devopsTeam = ['devops1', 'devops2', 'ops3'];
                const dataTeam = ['dataengineer1', 'dataengineer2'];
                
                if (assignees.some(a => securityTeam.includes(a))) {
                  bestArea = 'security-layer';
                  bestScore = Math.max(bestScore, 0.7);
                } else if (assignees.some(a => devopsTeam.includes(a))) {
                  bestArea = 'cicd-pipeline';
                  bestScore = Math.max(bestScore, 0.7);
                } else if (assignees.some(a => dataTeam.includes(a))) {
                  bestArea = 'data-management';
                  bestScore = Math.max(bestScore, 0.7);
                }
              }
            }
            
            // Apply manual override if provided
            if (areaOverride) {
              const validAreas = [
                'security-layer', 'monitoring-observability', 'performance-optimization',
                'container-orchestration', 'cicd-pipeline', 'data-management', 
                'api-gateway-services', 'docs', 'ui-components'
              ];
              
              if (validAreas.includes(areaOverride)) {
                bestArea = areaOverride;
                bestScore = 1.0;
                core.info(`üîß Manual area override applied: ${areaOverride}`);
              } else {
                core.warning(`‚ö†Ô∏è Invalid area override: ${areaOverride}`);
              }
            }
            
            const area = bestArea ? `area:${bestArea}` : null;
            
            // Log area classification results
            core.info('üìä Area classification scores:');
            for (const [area, score] of Object.entries(areaScores)) {
              if (score > 0) {
                core.info(`  - ${area}: ${score.toFixed(2)}`);
              }
            }
            core.info(`üìç Selected area: ${bestArea || 'None'} (score: ${bestScore.toFixed(2)})`);
            
            // Risk classification with more signals
            let riskFactors = {
              high: 0,
              medium: 0,
              low: 0
            };
            
            // Content-based risk factors
            if (hasAny(allContent, ['breaking change', 'critical', 'urgent', 'emergency', 'hot fix', 'hotfix'])) {
              riskFactors.high += 3;
            }
            
            if (hasAny(allContent, ['security', 'vulnerability', 'exploit', 'hack', 'breach', 'unsafe'])) {
              riskFactors.high += 2;
            }
            
            if (hasAny(allContent, ['refactor', 'migration', 'upgrade', 'update dependencies', 'technical debt'])) {
              riskFactors.medium += 2;
            }
            
            if (hasAny(allContent, ['fix', 'bug', 'error', 'crash', 'exception', 'issue'])) {
              riskFactors.medium += 1;
            }
            
            if (hasAny(allContent, ['improve', 'enhance', 'minor', 'small change', 'typo'])) {
              riskFactors.low += 2;
            }
            
            if (hasAny(allContent, ['documentation', 'docs', 'comment', 'readme'])) {
              riskFactors.low += 3;
            }
            
            // Size-based risk factors
            if (isPR) {
              const totalChanges = additions + deletions;
              if (totalChanges > 500) {
                riskFactors.high += Math.min(3, Math.floor(totalChanges / 500));
              } else if (totalChanges > 200) {
                riskFactors.medium += 2;
              } else if (totalChanges > 50) {
                riskFactors.medium += 1;
              } else {
                riskFactors.low += 1;
              }
              
              // Files affected
              if (files.length > 20) {
                riskFactors.high += 2;
              } else if (files.length > 10) {
                riskFactors.medium += 2;
              } else if (files.length > 5) {
                riskFactors.medium += 1;
              } else {
                riskFactors.low += 1;
              }
            }
            
            // Special handling for test issues
            if (minimalContent && title.toLowerCase().includes('test')) {
              // Test issues are generally low risk
              riskFactors.low += 3;
            }
            
            // Determine risk level
            let risk = 'risk:low';
            if (riskFactors.high > riskFactors.medium && riskFactors.high > riskFactors.low) {
              risk = 'risk:high';
            } else if (riskFactors.medium > riskFactors.low) {
              risk = 'risk:medium';
            }
            
            core.info(`üö® Risk classification: ${risk} (high: ${riskFactors.high}, medium: ${riskFactors.medium}, low: ${riskFactors.low})`);
            
            // Status label with smarter defaults
            let status = null;
            if (isPR) {
              if (merged) {
                status = 'status:done';
              } else if (prState === 'closed') {
                status = 'status:done';
              } else if (context.payload.action === 'ready_for_review' || !isDraft) {
                status = 'status:in-review';
              } else {
                status = 'status:in-progress';
              }
              
              // Check for draft or WIP title
              if (title.toLowerCase().startsWith('wip') || title.toLowerCase().startsWith('[wip]')) {
                status = 'status:in-progress';
              }
            } else {
              if (issueState === 'closed') {
                status = 'status:done';
              } else if (hasAny(allContent, ['wip', 'work in progress', 'working on', 'started', 'beginning'])) {
                status = 'status:in-progress';
              } else if (assignees.length > 0) {
                status = 'status:in-progress'; // If someone is assigned, likely in progress
              } else if (comments > 0) {
                // If there are comments, check for indicators
                if (commentsData.some(c => hasAny(c.body.toLowerCase(), ['blocked', 'blocking', 'blocker', 'can\'t continue']))) {
                  status = 'status:blocked';
                } else if (commentsData.some(c => hasAny(c.body.toLowerCase(), ['in progress', 'working on', 'started']))) {
                  status = 'status:in-progress';
                }
              } else {
                status = 'status:todo';
              }
              
              // For minimal test issues, default to todo
              if (minimalContent && title.toLowerCase().includes('test')) {
                status = 'status:todo';
              }
            }
            
            // Team assignment based on area, author, and other signals
            let team = null;
            if (bestArea === 'security-layer') {
              team = 'team:security';
            } else if (bestArea === 'cicd-pipeline' || bestArea === 'container-orchestration') {
              team = 'team:devops';
            } else if (bestArea === 'monitoring-observability') {
              team = 'team:qa';
            } else if (bestArea === 'ui-components') {
              team = 'team:frontend';
            } else if (bestArea === 'docs') {
              team = 'team:docs';
            } else {
              team = 'team:backend-dev'; // Default
            }
            
            // Implementation size based on various factors
            let size = null;
            if (isPR) {
              const total = additions + deletions;
              if (total <= 10) {
                size = 'size:xs';
              } else if (total <= 100) {
                size = 'size:small';
              } else if (total <= 250) {
                size = 'size:medium';
              } else if (total <= 500) {
                size = 'size:large';
              } else if (total <= 1000) {
                size = 'size:very-large';
              } else if (total <= 2000) {
                size = 'size:enterprise';
              } else {
                size = 'size:system';
              }
            } else {
              // For issues, try to estimate size based on content
              const contentSize = (title?.length || 0) + (body?.length || 0);
              const hasSubtasks = (body || '').includes('- [ ]');
              const hasManyLinks = ((body || '').match(/https?:\/\/\S+/g) || []).length > 3;
              
              if (contentSize < 50 && !hasSubtasks && !hasManyLinks) {
                size = 'size:small';
              } else if (contentSize < 500 || (hasSubtasks && (body.match(/- \[ \]/g) || []).length <= 5)) {
                size = 'size:medium';
              } else if (contentSize < 1000 || (hasSubtasks && (body.match(/- \[ \]/g) || []).length <= 10)) {
                size = 'size:large';
              } else {
                size = 'size:very-large';
              }
              
              // For minimal test issues, use small
              if (minimalContent && title.toLowerCase().includes('test')) {
                size = 'size:small';
              }
            }
            
            // Health score with smarter calculation
            let health = 'health:50-74'; // Default mid-range
            
            if (isPR) {
              let healthScore = 50; // Start at middle
              
              // Code quality signals
              const hasTests = pathHasAny(['test', 'spec', '__tests__']);
              const hasDocs = pathHasAny(['docs/', 'readme', '.md']);
              const hasComments = comments > 0;
              const docToCodeRatio = files.reduce((ratio, file) => {
                if (file.filename.match(/\.(md|txt|rst)$/)) {
                  return ratio + 1;
                }
                return ratio;
              }, 0) / Math.max(1, files.length);
              
              // Add points for positive signals
              if (hasTests) healthScore += 20;
              if (hasDocs) healthScore += 15;
              if (hasComments) healthScore += 5;
              if (docToCodeRatio > 0.1) healthScore += 10;
              
              // Subtract for negative signals
              const largeChange = changes > 500;
              if (largeChange) healthScore -= 15;
              if (files.length > 20) healthScore -= 10;
              if (!body || body.length < 30) healthScore -= 10;
              
              // Cap the score
              healthScore = Math.max(10, Math.min(100, healthScore));
              
              // Map to health labels
              if (healthScore >= 90) {
                health = 'health:90-99';
              } else if (healthScore >= 75) {
                health = 'health:75-89';
              } else if (healthScore >= 50) {
                health = 'health:50-74';
              } else if (healthScore >= 25) {
                health = 'health:25-49';
              } else {
                health = 'health:0-24';
              }
            } else {
              // For issues, base health on completeness
              let issueHealthScore = 50; // Start at middle
              
              if (body && body.length > 100) issueHealthScore += 10;
              if (body && body.includes('## Steps to reproduce')) issueHealthScore += 15;
              if (body && body.includes('## Expected behavior')) issueHealthScore += 10;
              if (body && (body.includes('```') || body.includes('~~~'))) issueHealthScore += 5; // Code blocks
              if (assignees.length > 0) issueHealthScore += 5;
              if (comments > 1) issueHealthScore += 5;
              if (labels.length > 0) issueHealthScore += 5;
              
              // Subtract points for minimal issues
              if (!body || body.length < 20) issueHealthScore -= 15;
              if (title.length < 10) issueHealthScore -= 10;
              
              // For minimal test issues, use medium health
              if (minimalContent && title.toLowerCase().includes('test')) {
                issueHealthScore = 60; // Middle range for test issues
              }
              
              // Cap and map to labels
              issueHealthScore = Math.max(10, Math.min(100, issueHealthScore));
              
              if (issueHealthScore >= 90) {
                health = 'health:90-99';
              } else if (issueHealthScore >= 75) {
                health = 'health:75-89';
              } else if (issueHealthScore >= 50) {
                health = 'health:50-74';
              } else if (issueHealthScore >= 25) {
                health = 'health:25-49';
              } else {
                health = 'health:0-24';
              }
            }
            
            // Iteration from milestone or content
            let iteration = null;
            const iterMatch = (milestoneTitle || allContent).match(/sprint[-\s]?(\d+)/i);
            if (iterMatch) {
              iteration = `iteration:sprint-${iterMatch[1]}`;
            } else if (hasAny(allContent, ['maintenance', 'maintain', 'upkeep', 'fix', 'bugfix'])) {
              iteration = 'iteration:maintenance';
            } else if (hasAny(allContent, ['research', 'spike', 'investigate', 'explore', 'poc', 'prototype'])) {
              iteration = 'iteration:research';
            }
            
            // Build label sets (single-choice categories)
            const singleChoiceSets = {
              risk: ['risk:low','risk:medium','risk:high'],
              status: ['status:todo','status:in-progress','status:in-review','status:blocked','status:done'],
              size: ['size:xs','size:small','size:medium','size:large','size:very-large','size:enterprise','size:system'],
              health: ['health:100','health:90-99','health:75-89','health:50-74','health:25-49','health:0-24'],
              iteration: ['iteration:sprint-1','iteration:sprint-2','iteration:sprint-3','iteration:sprint-4',
                         'iteration:sprint-5','iteration:sprint-6','iteration:epic','iteration:maintenance',
                         'iteration:research']
            };
            
            const toAdd = new Set();
            const toRemove = new Set();
            
            function setSingleChoice(target) {
              if (!target) return;
              for (const [_, set] of Object.entries(singleChoiceSets)) {
                if (set.includes(target)) {
                  set.forEach(l => { if (existing.has(l) && l !== target) toRemove.add(l); });
                }
              }
              if (!existing.has(target)) toAdd.add(target);
            }
            
            // Apply choices
            setSingleChoice(risk);
            setSingleChoice(status);
            setSingleChoice(size);
            setSingleChoice(health);
            setSingleChoice(iteration);
            if (area && !existing.has(area)) toAdd.add(area);
            if (team && !existing.has(team)) toAdd.add(team);
            
            const addList = Array.from(toAdd);
            const removeList = Array.from(toRemove);
            
            // Record classifications for next step
            const classifications = {
              area: area ? { 
                value: area.split(':')[1], 
                confidence: bestScore.toFixed(2),
                source: 'advanced_heuristic' 
              } : null,
              risk: risk ? { 
                value: risk.split(':')[1], 
                factors: riskFactors,
                source: 'advanced_heuristic' 
              } : null,
              status: status ? { 
                value: status.split(':')[1], 
                source: 'context_aware' 
              } : null,
              team: team ? { 
                value: team.split(':')[1], 
                source: 'area_based' 
              } : null,
              size: size ? { 
                value: size.split(':')[1], 
                source: isPR ? 'code_stats' : 'content_estimate' 
              } : null,
              health: health ? { 
                value: health.split(':')[1], 
                source: isPR ? 'code_quality' : 'issue_completeness' 
              } : null,
              iteration: iteration ? { 
                value: iteration.split(':')[1], 
                source: 'content_match' 
              } : null
            };
            
            // Dry-run log
            if (dryRun) {
              core.info('üß™ DRY RUN: Label changes preview');
              core.info(`Would add: ${addList.join(', ') || 'None'}`);
              core.info(`Would remove: ${removeList.join(', ') || 'None'}`);
              return {
                dryRun: true,
                item: {
                  type: isPR ? 'pull_request' : 'issue',
                  number: number,
                  title: title,
                  url: item.html_url,
                  node_id: nodeId,
                  author: author,
                  created_at: createdAt,
                  updated_at: updatedAt,
                  assignees: assignees,
                  comments: comments
                },
                labels: {
                  existing: Array.from(existing),
                  toAdd: addList,
                  toRemove: removeList
                },
                classifications: classifications,
                stats: { additions, deletions, changes }
              };
            }
            
            // Apply removals first
            for (const l of removeList) {
              try {
                await github.rest.issues.removeLabel({ 
                  owner, repo, issue_number: number, name: l 
                });
                core.info(`Removed label: ${l}`);
              } catch (e) {
                if (e.status !== 404) core.warning(`Failed to remove label ${l}: ${e.message}`);
              }
            }
            
            // Apply additions
            if (addList.length) {
              try {
                await github.rest.issues.addLabels({ 
                  owner, repo, issue_number: number, labels: addList 
                });
                core.info(`Added labels: ${addList.join(', ')}`);
              } catch (e) {
                core.warning(`Failed to add labels: ${e.message}`);
              }
            } else {
              core.info('No labels to add');
            }
            
            // Return final state for artifact
            const finalLabels = [...labels.filter(l => !removeList.includes(l)), ...addList];
            
            return {
              item: {
                type: isPR ? 'pull_request' : 'issue',
                number: number,
                title: title,
                body: body,
                url: item.html_url,
                state: isPR ? prState : issueState,
                isPR: isPR,
                isDraft: isDraft,
                merged: merged,
                node_id: nodeId,
                author: author,
                created_at: createdAt,
                updated_at: updatedAt,
                assignees: assignees,
                comments: comments
              },
              labels: {
                final: finalLabels,
                added: addList,
                removed: removeList
              },
              classifications: classifications,
              stats: { additions, deletions, changes },
              files: files.map(f => ({ 
                filename: f.filename, 
                additions: f.additions, 
                deletions: f.deletions 
              }))
            };

      - name: Create Classification Artifact
        id: create_artifact
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            
            // Get the classification results from the previous step
            const result = ${{ toJSON(steps.auto_labeler.outputs.result) }};
            
            // Add metadata
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                updated_at: process.env.UPDATED_AT,
                version: process.env.WORKFLOW_VERSION,
                user: context.actor,
                event_type: context.eventName,
                action: context.payload.action || 'manual',
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`
              },
              ...result
            };
            
            // Ensure node_id is present
            if (!artifactData.item || !artifactData.item.node_id) {
              if ('${{ steps.extract_info.outputs.node_id }}') {
                if (!artifactData.item) artifactData.item = {};
                artifactData.item.node_id = '${{ steps.extract_info.outputs.node_id }}';
                core.info('üìå Added node_id from extract_info step to artifact');
              } else {
                core.warning('‚ö†Ô∏è No node_id available in classification or extract_info outputs');
              }
            }
            
            // Write to file
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            core.info('üíæ Created classification artifact with the following data:');
            core.info(`- Item type: ${artifactData.item?.type || 'Unknown'}`);
            core.info(`- Item number: ${artifactData.item?.number || 'Unknown'}`);
            core.info(`- Node ID present: ${artifactData.item?.node_id ? 'Yes' : 'No'}`);
            
            core.setOutput('artifact_name', artifactName);
            
      - name: Upload Classification Artifact
        if: steps.extract_info.outputs.has_item == 'true' && steps.create_artifact.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 1

  # Step 2: Add to Project with classification data
  project_integration:
    name: "üìã Project Integration"
    needs: classify
    if: needs.classify.outputs.has_item == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Classification Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}
          
      - name: Debug Classification Data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              const data = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('üìä Classification Data Debug:');
              core.info(`- File exists: Yes`);
              core.info(`- Has metadata: ${data.metadata ? 'Yes' : 'No'}`);
              core.info(`- Has item: ${data.item ? 'Yes' : 'No'}`);
              
              if (data.item) {
                core.info(`- Item number: ${data.item.number || 'Not found'}`);
                core.info(`- Item type: ${data.item.type || 'Not found'}`);
                core.info(`- Node ID: ${data.item.node_id || 'Not found'}`);
              }
              
              if (!data.item?.node_id) {
                // Try to fetch node_id directly as fallback
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                const number = data.item?.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
                const isPR = data.item?.type === 'pull_request' || '${{ needs.classify.outputs.item_type }}' === 'pull_request';
                
                if (number) {
                  core.info(`üîÑ Attempting to fetch node_id for ${isPR ? 'PR' : 'Issue'} #${number} as fallback...`);
                  
                  try {
                    if (isPR) {
                      const pr = await github.rest.pulls.get({owner, repo, pull_number: number});
                      data.item.node_id = pr.data.node_id;
                    } else {
                      const issue = await github.rest.issues.get({owner, repo, issue_number: number});
                      data.item.node_id = issue.data.node_id;
                    }
                    
                    if (data.item.node_id) {
                      core.info(`‚úÖ Successfully retrieved node_id: ${data.item.node_id}`);
                      fs.writeFileSync('classification.json', JSON.stringify(data, null, 2));
                    }
                  } catch (e) {
                    core.warning(`‚ùå Failed to fetch node_id: ${e.message}`);
                  }
                }
              }
            } catch (e) {
              core.error(`‚ùå Failed to parse classification.json: ${e.message}`);
            }

      - name: Add to Project with Classification
        uses: actions/github-script@v7
        env:
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
          PROJECT_TITLE: ${{ github.event.inputs.project_title || env.DEFAULT_PROJECT_TITLE }}
          NODE_ID_FALLBACK: ${{ needs.classify.outputs.node_id }}
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const hasPat = !!(process.env.GH_PROJECT_TOKEN && process.env.GH_PROJECT_TOKEN.trim());
            const isDryRun = !hasPat || '${{ github.event.inputs.dry_run }}' === 'true';
            
            // Load classification data
            let classification;
            try {
              classification = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('‚úÖ Loaded classification data');
            } catch (e) {
              core.setFailed(`Failed to load classification data: ${e.message}`);
              return;
            }
            
            // Extract key information
            const metadata = classification.metadata || {};
            const item = classification.item || {};
            const classifications = classification.classifications || {};
            const labels = classification.labels?.final || [];
            
            const itemType = item.type || '${{ needs.classify.outputs.item_type }}';
            const itemNumber = item.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
            const isPR = itemType === 'pull_request';
            
            // Get node_id from classification data or fallback
            let contentId = item.node_id || process.env.NODE_ID_FALLBACK;
            
            // If still no node_id, fetch it directly
            if (!contentId) {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              try {
                core.info(`üîÑ No node_id found in data, fetching directly for ${isPR ? 'PR' : 'Issue'} #${itemNumber}...`);
                
                if (isPR) {
                  const pr = await github.rest.pulls.get({owner, repo, pull_number: itemNumber});
                  contentId = pr.data.node_id;
                } else {
                  const issue = await github.rest.issues.get({owner, repo, issue_number: itemNumber});
                  contentId = issue.data.node_id;
                }
                
                if (contentId) {
                  core.info(`‚úÖ Successfully retrieved node_id: ${contentId}`);
                }
              } catch (e) {
                core.setFailed(`Failed to fetch node_id: ${e.message}`);
                return;
              }
            }
            
            if (!contentId) {
              core.setFailed('Missing node_id. Cannot add to project.');
              return;
            }
            
            // Project configuration
            const ownerLogin = context.repo.owner;
            const projectTitle = process.env.PROJECT_TITLE || 'MerajutASA Program Board';
            
            core.info(`üéØ Processing ${isPR ? 'PR' : 'Issue'} #${itemNumber} for project "${projectTitle}"`);
            core.info(`Using node ID: ${contentId}`);
            
            if (isDryRun) {
              core.info('üß™ DRY RUN MODE: Will simulate but not make actual changes');
              if (!hasPat) {
                core.info('‚ö†Ô∏è No PAT provided, cannot make GraphQL queries to Projects V2 API');
              }
            }
            
            // Project lookup
            let project;
            try {
              if (isDryRun && !hasPat) {
                core.info('üß™ DRY RUN: Would look up project');
                project = { id: 'dry-run-project-id', title: projectTitle, url: 'https://github.com/users/Andhika-Rey/projects/1' };
              } else {
                const projectQuery = `
                  query($owner: String!) {
                    repositoryOwner(login: $owner) {
                      id
                      login
                      ... on User {
                        projectsV2(first: 20) {
                          nodes {
                            id title url public
                            fields(first: 50) {
                              nodes {
                                __typename
                                ... on ProjectV2FieldCommon { id name dataType }
                                ... on ProjectV2SingleSelectField { 
                                  id name dataType 
                                  options { id name color description } 
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                const resp = await github.graphql(projectQuery, { owner: ownerLogin });
                const nodes = resp.repositoryOwner?.projectsV2?.nodes || [];
                
                project = nodes.find(p => p.title === projectTitle)
                      || nodes.find(p => p.title.toLowerCase() === projectTitle.toLowerCase())
                      || nodes.find(p => p.title === 'MerajutASA Program Board');
                      
                if (!project) {
                  core.warning(`‚ùå Project "${projectTitle}" not found in ${ownerLogin}'s account`);
                  core.info('üí° Available projects:');
                  for (const p of nodes) {
                    core.info(`- ${p.title}`);
                  }
                  return;
                }
              }
            } catch (error) {
              core.warning(`‚ùå Project lookup failed: ${error.message}`);
              return;
            }
            
            core.info(`‚úÖ Using project: ${project.title} (${project.url || 'N/A'})`);
            
            const projectId = project.id;
            const fields = isDryRun && !hasPat ? [] : (project.fields?.nodes || []);
            
            // Helper functions for field operations
            function getField(name) { 
              return fields.find(f => f.name === name); 
            }
            
            async function setSingleSelect(fieldName, optionName) {
              const field = getField(fieldName);
              if (!field || field.dataType !== 'SINGLE_SELECT') {
                core.info(`‚ö†Ô∏è Field "${fieldName}" not found or not a single select field`);
                return false;
              }
              
              const option = (field.options || []).find(o => 
                o.name.toLowerCase() === optionName.toLowerCase()
              );
              
              if (!option) {
                core.info(`‚ö†Ô∏è Option "${optionName}" not found for field "${fieldName}"`);
                core.info(`Available options: ${(field.options || []).map(o => o.name).join(', ')}`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`üß™ DRY RUN: Would set ${fieldName} = ${optionName}`);
                return true; 
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  optionId: option.id 
                });
                core.info(`‚úÖ Set ${fieldName} = ${optionName}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            async function setDate(fieldName, value) {
              const field = getField(fieldName);
              if (!field || field.dataType !== 'DATE') {
                core.info(`‚ö†Ô∏è Field "${fieldName}" not found or not a date field`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`üß™ DRY RUN: Would set ${fieldName} = ${value}`);
                return true;
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: Date!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { date: $v }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  v: value 
                });
                core.info(`‚úÖ Set ${fieldName} = ${value}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            async function setNumber(fieldName, value) {
              const field = getField(fieldName);
              if (!field || field.dataType !== 'NUMBER') {
                core.info(`‚ö†Ô∏è Field "${fieldName}" not found or not a number field`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`üß™ DRY RUN: Would set ${fieldName} = ${value}`);
                return true;
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: Float!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId, 
                      value: { number: $v }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  v: value 
                });
                core.info(`‚úÖ Set ${fieldName} = ${value}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            async function setText(fieldName, value, options = {}) {
              const { overwrite = true } = options;
              
              if (!value || !String(value).trim()) {
                if (!overwrite) {
                  core.info(`Skipping empty text value for ${fieldName} (overwrite=false)`);
                  return false;
                }
              }
              
              const field = getField(fieldName);
              if (!field || field.dataType !== 'TEXT') {
                core.info(`‚ö†Ô∏è Field "${fieldName}" not found or not a text field`);
                return false;
              }
              
              if (isDryRun) { 
                core.info(`üß™ DRY RUN: Would set ${fieldName} = ${value}`);
                return true;
              }
              
              try {
                const mutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $v: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { text: $v }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `;
                await github.graphql(mutation, { 
                  projectId, 
                  itemId, 
                  fieldId: field.id, 
                  v: value 
                });
                core.info(`‚úÖ Set ${fieldName} = ${value}`);
                return true;
              } catch (e) {
                core.warning(`Failed to set ${fieldName}: ${e.message}`);
                return false;
              }
            }
            
            // Ensure item exists in project or add it
            let itemId;
            if (isDryRun && !hasPat) {
              core.info('üß™ DRY RUN: Would check if item exists in project');
              itemId = 'dry-run-item-id';
            } else {
              // First, check if item already exists
              const itemQuery = `
                query($projectId: ID!, $first: Int = 100) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: $first) {
                        nodes {
                          id
                          content {
                            ... on Issue { id number repository { nameWithOwner } }
                            ... on PullRequest { id number repository { nameWithOwner } }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const itemsResp = await github.graphql(itemQuery, { projectId });
              const items = itemsResp.node.items.nodes;
              
              const repoFullName = `${context.repo.owner}/${context.repo.repo}`;
              const existingItem = items.find(i => 
                i.content && 
                i.content.number === itemNumber && 
                i.content.repository?.nameWithOwner === repoFullName
              );
              
              if (existingItem) {
                itemId = existingItem.id;
                core.info(`üîÑ Item already exists in project, ID: ${itemId}`);
              } else {
                // Add item to project
                core.info(`‚ûï Adding ${isPR ? 'PR' : 'Issue'} #${itemNumber} to project`);
                
                try {
                  const addMutation = `
                    mutation($projectId: ID!, $contentId: ID!) { 
                      addProjectV2ItemById(input: {
                        projectId: $projectId, 
                        contentId: $contentId
                      }) { 
                        item { id } 
                      } 
                    }
                  `;
                  
                  core.info(`Using contentId: ${contentId}`);
                  
                  const addResult = await github.graphql(addMutation, { 
                    projectId, 
                    contentId 
                  });
                  
                  itemId = addResult.addProjectV2ItemById.item.id;
                  core.info(`‚úÖ Added item with ID: ${itemId}`);
                } catch (e) {
                  core.setFailed(`Failed to add item to project: ${e.message}`);
                  return;
                }
              }
            }
            
            // Apply field mappings based on classification results
            const results = [];
            
            // Map classifications to project fields
            if (classifications.area?.value) {
              const areaKey = classifications.area.value;
              const areaMapping = { 
                'security-layer': 'Security Layer', 
                'monitoring-observability': 'Monitoring & Observability', 
                'performance-optimization': 'Performance Optimization', 
                'container-orchestration': 'Container Orchestration',
                'cicd-pipeline': 'CI/CD Pipeline',
                'data-management': 'Data Management',
                'api-gateway-services': 'API Gateway & Services',
                'docs': 'Documentation'
              };
              const mappedArea = areaMapping[areaKey] || areaKey.replace(/-/g, ' ');
              results.push(await setSingleSelect('Area', mappedArea));
            }
            
            if (classifications.risk?.value) {
              const riskMapping = {
                'low': 'Low', 
                'medium': 'Medium', 
                'high': 'High'
              };
              results.push(await setSingleSelect('Risk', riskMapping[classifications.risk.value] || 'Medium'));
            }
            
            if (classifications.status?.value) {
              const statusMapping = {
                'todo': 'To Do',
                'in-progress': 'In Progress',
                'in-review': 'In Review',
                'blocked': 'Blocked',
                'done': 'Done'
              };
              results.push(await setSingleSelect('Status', statusMapping[classifications.status.value] || 'To Do'));
            }
            
            if (classifications.team?.value) {
              const teamValue = classifications.team.value.replace(/-/g, ' ');
              results.push(await setSingleSelect('Team Assignment', teamValue));
            }
            
            if (classifications.size?.value) {
              const sizeMapping = {
                'small': '< 10KB',
                'medium': '10-25KB',
                'large': '25-50KB',
                'very-large': '50-100KB',
                'enterprise': '100KB+',
                'system': 'Enterprise Scale'
              };
              results.push(await setSingleSelect('Implementation Size', sizeMapping[classifications.size.value] || classifications.size.value));
            }
            
            if (classifications.health?.value) {
              const healthMapping = {
                '100': '100/100',
                '90-99': '90-99/100',
                '75-89': '75-89/100',
                '50-74': '50-74/100',
                '25-49': '25-49/100',
                '0-24': '0-24/100'
              };
              results.push(await setSingleSelect('Health Score', healthMapping[classifications.health.value] || classifications.health.value));
            }
            
            if (classifications.iteration?.value) {
              const iterValue = classifications.iteration.value.replace(/-/g, ' ');
              results.push(await setSingleSelect('Iteration', iterValue));
            }
            
            // Process labels for additional fields
            const labelSet = new Set(labels || []);
            
            // Phase from labels
            const phaseLabel = Array.from(labelSet).find(l => l.toLowerCase().startsWith('phase:'));
            if (phaseLabel) {
              const raw = phaseLabel.slice('phase:'.length).toLowerCase();
              const phaseMapping = {
                '1': 'Phase 1',
                '2-week-1': 'Phase 2 W1',
                '2-week-2': 'Phase 2 W2',
                '2-week-3': 'Phase 2 W3',
                '2-week-4': 'Phase 2 W4',
                '2-week-5': 'Phase 2 W5',
                '2-week-6': 'Phase 2 W6',
                '2-week-7': 'Phase 2 W7',
                '2-week-8': 'Phase 2 W8',
                '3-q1': 'Phase 3 Q1',
                '3-q2': 'Phase 3 Q2',
                '3-q3': 'Phase 3 Q3',
                '3-q4': 'Phase 3 Q4'
              };
              const target = phaseMapping[raw];
              if (target) results.push(await setSingleSelect('Phase', target));
            }
            
            // Dates from labels
            const startDateLabel = Array.from(labelSet).find(l => l.startsWith('start:'));
            if (startDateLabel) {
              const dateStr = startDateLabel.slice('start:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                results.push(await setDate('Start date', dateStr));
              }
            }
            
            const dueDateLabel = Array.from(labelSet).find(l => l.startsWith('due:'));
            if (dueDateLabel) {
              const dateStr = dueDateLabel.slice('due:'.length);
              if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                results.push(await setDate('Target date', dateStr));
              }
            }
            
            // Estimate from labels
            const estimateLabel = Array.from(labelSet).find(l => l.startsWith('est:h:'));
            if (estimateLabel) {
              const hours = parseFloat(estimateLabel.slice('est:h:'.length));
              if (!isNaN(hours) && hours > 0) {
                results.push(await setNumber('Estimate (h)', hours));
              }
            }
            
            // Owner from original classification data
            if (item.assignees && item.assignees.length > 0) {
              results.push(await setText('Owner (text)', item.assignees[0]));
            } else if (item.author) {
              results.push(await setText('Owner (text)', item.author, { overwrite: false }));
            }
            
            // Links from body
            const urlMatch = (item.body || '').match(/https?:\/\/\S+/);
            if (urlMatch) {
              results.push(await setText('Links', urlMatch[0], { overwrite: false }));
            }
            
            // Milestone
            if (item.milestone?.title) {
              results.push(await setText('Milestone', item.milestone.title));
            }
            
            // Write integration summary
            const summary = {
              metadata: metadata,
              project: {
                title: project.title,
                url: project.url || '',
                owner: ownerLogin
              },
              item: {
                type: itemType,
                number: itemNumber,
                title: item.title,
                added_to_project: !isDryRun
              },
              fields_updated: results.filter(Boolean).length,
              dry_run: isDryRun,
              timestamp: new Date().toISOString()
            };
            
            core.info('üìä Project integration complete');
            if (isDryRun) {
              core.info('üß™ This was a dry run - no actual changes were made');
            } else {
              core.info(`‚úÖ Successfully added to project and updated ${results.filter(Boolean).length} fields`);
            }
            
            // Write summary for artifact
            try {
              fs.writeFileSync('project-integration-summary.json', JSON.stringify(summary, null, 2));
            } catch (e) {
              core.warning(`Failed to write summary: ${e.message}`);
            }

      - name: Upload Integration Summary
        uses: actions/upload-artifact@v4
        with:
          name: project-integration-summary
          path: project-integration-summary.json
          retention-days: 7