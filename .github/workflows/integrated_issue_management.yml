name: Integrated Issue Management (Personal Account)

# Workflow that combines auto-labeling and project management
# Created: 2025-08-20
# Author: Andhika-Rey
# Version: 1.1.0

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      project_title:
        description: 'Project title to target'
        required: false
        default: "MerajutASA Program Board"
      area:
        description: 'Override area classification'
        required: false
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  DEFAULT_PROJECT_TITLE: "MerajutASA Program Board"
  WORKFLOW_VERSION: "1.1.0"
  CREATED_AT: "2025-08-20"
  UPDATED_AT: "2025-08-20 04:40:25"
  CREATED_BY: "Andhika-Rey"

jobs:
  # Step 1: Extract information and classify the issue/PR
  classify:
    name: "ðŸ” Extract & Classify"
    runs-on: ubuntu-latest
    outputs:
      item_number: ${{ steps.extract_info.outputs.item_number }}
      item_type: ${{ steps.extract_info.outputs.item_type }}
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      has_item: ${{ steps.extract_info.outputs.has_item }}
      node_id: ${{ steps.extract_info.outputs.node_id }}
    
    steps:
      - name: Extract Item Information
        id: extract_info
        uses: actions/github-script@v7
        with:
          script: |
            const { eventName, payload, repo } = context;
            const owner = repo.owner;
            const repoName = repo.repo;
            
            let isPR = eventName === 'pull_request';
            let number = null;
            let hasItem = false;
            let nodeId = null;
            
            // Handle different event types to extract item number
            if (eventName === 'pull_request') {
              number = payload.pull_request.number;
              nodeId = payload.pull_request.node_id;
              hasItem = true;
            } else if ((eventName === 'issues' || eventName === 'issue_comment') && payload.issue) {
              number = payload.issue.number;
              nodeId = payload.issue.node_id;
              isPR = !!payload.issue.pull_request;
              hasItem = true;
            } else if (eventName === 'workflow_dispatch' && payload.inputs && payload.inputs.number) {
              number = parseInt(payload.inputs.number, 10);
              if (!isNaN(number)) {
                // Determine if number refers to a PR
                try {
                  const pr = await github.rest.pulls.get({
                    owner,
                    repo: repoName,
                    pull_number: number
                  });
                  isPR = true;
                  nodeId = pr.data.node_id;
                  hasItem = true;
                } catch (e) {
                  try {
                    const issue = await github.rest.issues.get({
                      owner,
                      repo: repoName,
                      issue_number: number
                    });
                    isPR = false;
                    nodeId = issue.data.node_id;
                    hasItem = true;
                  } catch (e) {
                    core.warning(`Item #${number} not found as issue or PR`);
                    hasItem = false;
                  }
                }
              }
            }
            
            if (hasItem) {
              core.info(`âœ… Found ${isPR ? 'PR' : 'Issue'} #${number}`);
              if (nodeId) {
                core.info(`ðŸ“Œ Node ID: ${nodeId}`);
              } else {
                core.warning('âš ï¸ No Node ID found, will try to fetch it in next step');
              }
            } else {
              core.warning('âš ï¸ No valid issue/PR number found in this event');
            }
            
            core.setOutput('item_number', number ? number.toString() : '');
            core.setOutput('item_type', isPR ? 'pull_request' : 'issue');
            core.setOutput('has_item', hasItem ? 'true' : 'false');
            if (nodeId) {
              core.setOutput('node_id', nodeId);
            }

      # Skip the rest if no valid item was found
      - name: Check for valid item
        id: check_item
        if: steps.extract_info.outputs.has_item != 'true'
        run: |
          echo "::notice::No valid issue or PR found to process"
          exit 0

      - name: Fetch Item Details
        id: fetch_details
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
            const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            let title = '', body = '', labels = [], milestoneTitle = '';
            let prState = null, isDraft = false, merged = false, issueState = null;
            let item = null;
            let nodeId = '${{ steps.extract_info.outputs.node_id }}';
            let assignees = [], comments = 0, commentsData = [];
            let createdAt, updatedAt;
            let author = null;
            let files = [], additions = 0, deletions = 0, changes = 0;
            
            try {
              if (isPR) {
                const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                item = pr;
                title = pr.title || '';
                body = pr.body || '';
                labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = pr.milestone?.title || '';
                prState = typeof pr.state === 'string' ? pr.state.toLowerCase() : null;
                isDraft = !!pr.draft;
                merged = !!pr.merged;
                if (!nodeId) nodeId = pr.node_id;
                assignees = pr.assignees?.map(a => a.login) || [];
                author = pr.user?.login;
                createdAt = pr.created_at;
                updatedAt = pr.updated_at;
                
                // Get PR comments
                const prComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = prComments.data.length;
                commentsData = prComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                }));
                
                // Get PR review comments
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner, repo, pull_number: number, per_page: 100
                });
                comments += reviewComments.data.length;
                commentsData.push(...reviewComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                })));
                
                // Get PR files
                const perPage = 100;
                let page = 1;
                while (true) {
                  try {
                    const resp = await github.rest.pulls.listFiles({ 
                      owner, repo, pull_number: number, per_page: perPage, page 
                    });
                    files.push(...resp.data);
                    if (resp.data.length < perPage) break;
                    page += 1;
                  } catch (e) {
                    core.warning(`Failed to get PR files page ${page}: ${e.message}`);
                    break;
                  }
                }
                additions = files.reduce((s, f) => s + (f.additions || 0), 0);
                deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
                changes = files.reduce((s, f) => s + (f.changes || 0), 0);
              } else {
                const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                item = issue;
                title = issue.title || '';
                body = issue.body || '';
                labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = issue.milestone?.title || '';
                issueState = typeof issue.state === 'string' ? issue.state.toLowerCase() : null;
                if (!nodeId) nodeId = issue.node_id;
                assignees = issue.assignees?.map(a => a.login) || [];
                author = issue.user?.login;
                createdAt = issue.created_at;
                updatedAt = issue.updated_at;
                
                // Get issue comments
                const issueComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = issueComments.data.length;
                commentsData = issueComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login, 
                  created_at: c.created_at
                }));
              }
              
              core.info(`ðŸ“ Title: ${title}`);
              core.info(`ðŸ‘¤ Author: ${author || 'Unknown'}`);
              core.info(`ðŸ’¬ Comments: ${comments}`);
              core.info(`ðŸ“… Created: ${createdAt}`);
              
              if (isPR) {
                core.info(`ðŸ“Š PR Stats: +${additions} -${deletions} changes: ${changes}`);
              }
              
            } catch (e) {
              core.warning(`âš ï¸ Error fetching details: ${e.message}`);
            }
            
            // Save to outputs for next steps
            return {
              item: {
                number,
                title,
                body,
                isPR,
                labels,
                nodeId,
                milestoneTitle,
                state: isPR ? prState : issueState,
                isDraft,
                merged,
                assignees,
                author,
                createdAt,
                updatedAt,
                comments,
                commentsData,
                url: isPR ? `https://github.com/${owner}/${repo}/pull/${number}` : `https://github.com/${owner}/${repo}/issues/${number}`
              },
              files: {
                list: files.map(f => ({ filename: f.filename, additions: f.additions, deletions: f.deletions })),
                stats: { additions, deletions, changes }
              }
            };

      - name: Analyze and Apply Labels
        id: auto_labeler
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Load or use the classify module
            async function classifyItem() {
              const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
              const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
              const nodeId = '${{ steps.extract_info.outputs.node_id }}';
              const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
              const areaOverride = '${{ github.event.inputs.area }}';
              
              // Get fetch_details step result
              let itemDetails;
              try {
                const detailsOutput = ${{ toJSON(steps.fetch_details.outputs.result) }};
                core.info(`Received fetch_details output: ${typeof detailsOutput}`);
                
                // Parse the details if it's a string
                if (typeof detailsOutput === 'string') {
                  itemDetails = JSON.parse(detailsOutput);
                } else {
                  itemDetails = detailsOutput;
                }
                
                // Validate itemDetails structure
                if (!itemDetails || !itemDetails.item) {
                  core.warning('Invalid or missing itemDetails structure!');
                  // Create fallback structure
                  itemDetails = { 
                    item: { 
                      title: '', 
                      body: '', 
                      labels: [],
                      nodeId: nodeId,
                      number: number,
                      isPR: isPR 
                    }, 
                    files: { list: [], stats: { additions: 0, deletions: 0, changes: 0 } } 
                  };
                  
                  // Fetch directly as fallback
                  core.info('Fetching issue/PR details directly as fallback...');
                  const owner = context.repo.owner;
                  const repo = context.repo.repo;
                  
                  if (isPR) {
                    const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                    itemDetails.item.title = pr.title || '';
                    itemDetails.item.body = pr.body || '';
                    itemDetails.item.labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                    itemDetails.item.nodeId = pr.node_id;
                  } else {
                    const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                    itemDetails.item.title = issue.title || '';
                    itemDetails.item.body = issue.body || '';
                    itemDetails.item.labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                    itemDetails.item.nodeId = issue.node_id;
                  }
                }
              } catch (error) {
                core.warning(`Error processing item details: ${error.message}`);
                // Use minimal fallback data
                itemDetails = { 
                  item: { 
                    title: 'Unknown Title', 
                    body: '', 
                    labels: [],
                    nodeId: nodeId,
                    number: number,
                    isPR: isPR 
                  },
                  files: { list: [], stats: { additions: 0, deletions: 0, changes: 0 } } 
                };
              }
              
              // Prevent relabel loops when the actor is the bot itself
              if ((context.eventName === 'issues' && ['labeled','unlabeled'].includes(context.payload.action)) ||
                  (context.eventName === 'pull_request' && ['labeled','unlabeled'].includes(context.payload.action))) {
                if (context.actor === 'github-actions[bot]') {
                  core.info('Skip to prevent relabel loop (actor is github-actions[bot]).');
                  return { skipped: true, reason: 'bot_actor' };
                }
              }
              
              // Extract item details - with safe accessors
              const item = itemDetails.item || {};
              const files = itemDetails.files || { list: [], stats: { additions: 0, deletions: 0, changes: 0 } };
              
              // Extract all the details we need - with safe accessors
              const title = item.title || '';
              const body = item.body || '';
              const labels = item.labels || [];
              const milestoneTitle = item.milestoneTitle || '';
              const assignees = item.assignees || [];
              const author = item.author;
              const commentsData = item.commentsData || [];
              
              core.info(`Processing: "${title}" (${isPR ? 'PR' : 'Issue'} #${number})`);
              
              // Enhanced content analysis with multiple approaches
              const allContent = [
                title,
                body,
                ...(commentsData || []).map(c => c.body)
              ].filter(Boolean).join('\n').toLowerCase();
              
              const filePaths = (files.list || []).map(f => (f.filename || '').toLowerCase());
              const additions = files.stats?.additions || 0;
              const deletions = files.stats?.deletions || 0;
              const changes = files.stats?.changes || 0;
              
              // Helper functions
              const hasAny = (s, arr) => arr.some(k => s.includes(k));
              const pathHasAny = (arr) => filePaths.some(p => arr.some(k => p.includes(k)));
              
              // Special handling for "test" issues
              const minimalContent = title.length + (body?.length || 0) < 20;
              
              // Classification logic for "test" issues
              let area, risk, status, team, size, health;
              
              if (minimalContent && title.toLowerCase().includes('test')) {
                area = 'area:monitoring-observability'; // QA related
                risk = 'risk:low';
                status = 'status:todo';
                team = 'team:qa';
                size = 'size:small';
                health = 'health:75-89';
                
                core.info('âœ… Test-related issue detected, using special classification');
              } else {
                // Default classification for non-test issues
                area = 'area:api-gateway-services'; 
                risk = 'risk:medium';
                status = isPR ? 'status:in-review' : 'status:in-progress';
                team = 'team:backend-dev';
                size = 'size:medium';
                health = 'health:50-74';
                
                // Override from input parameter
                if (areaOverride) {
                  area = `area:${areaOverride}`;
                  core.info(`ðŸ”§ Manual area override applied: ${areaOverride}`);
                }
              }
              
              // Apply labels
              const existing = new Set(labels);
              const toAdd = new Set();
              const toRemove = new Set();
              
              if (area && !existing.has(area)) toAdd.add(area);
              if (!existing.has(risk)) toAdd.add(risk);
              if (!existing.has(status)) toAdd.add(status);
              if (!existing.has(team)) toAdd.add(team);
              if (!existing.has(size)) toAdd.add(size);
              if (!existing.has(health)) toAdd.add(health);
              
              const addList = Array.from(toAdd);
              const removeList = Array.from(toRemove);
              
              // Record classifications
              const classifications = {
                area: area ? { value: area.split(':')[1], confidence: 0.8 } : null,
                risk: risk ? { value: risk.split(':')[1] } : null,
                status: status ? { value: status.split(':')[1] } : null,
                team: team ? { value: team.split(':')[1] } : null,
                size: size ? { value: size.split(':')[1] } : null,
                health: health ? { value: health.split(':')[1] } : null
              };
              
              // Dry-run or apply labels
              if (dryRun) {
                core.info('ðŸ§ª DRY RUN: Label changes preview');
                core.info(`Would add: ${addList.join(', ') || 'None'}`);
                return {
                  dryRun: true,
                  item: {
                    type: isPR ? 'pull_request' : 'issue',
                    number: number,
                    title: title,
                    node_id: nodeId,
                    author: author
                  },
                  labels: { existing: Array.from(existing), toAdd: addList, toRemove: removeList },
                  classifications: classifications
                };
              }
              
              // Apply labels
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              if (addList.length) {
                try {
                  await github.rest.issues.addLabels({ 
                    owner, repo, issue_number: number, labels: addList 
                  });
                  core.info(`Added labels: ${addList.join(', ')}`);
                } catch (e) {
                  core.warning(`Failed to add labels: ${e.message}`);
                }
              }
              
              const finalLabels = [...labels.filter(l => !removeList.includes(l)), ...addList];
              
              return {
                item: {
                  type: isPR ? 'pull_request' : 'issue',
                  number: number,
                  title: title,
                  body: body,
                  state: item.state,
                  isPR: isPR,
                  node_id: nodeId,
                  author: author,
                  url: item.url
                },
                labels: { final: finalLabels, added: addList, removed: removeList },
                classifications: classifications
              };
            }
            
            // Execute the classification
            return await classifyItem();

      - name: Create Classification Artifact
        id: create_artifact
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            
            // Get the classification results from the previous step
            const result = ${{ toJSON(steps.auto_labeler.outputs.result) }};
            
            // Add metadata
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                updated_at: process.env.UPDATED_AT,
                version: process.env.WORKFLOW_VERSION,
                user: context.actor,
                event_type: context.eventName,
                action: context.payload.action || 'manual',
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`
              },
              ...result
            };
            
            // Ensure node_id is present
            if (!artifactData.item || !artifactData.item.node_id) {
              if ('${{ steps.extract_info.outputs.node_id }}') {
                if (!artifactData.item) artifactData.item = {};
                artifactData.item.node_id = '${{ steps.extract_info.outputs.node_id }}';
                core.info('ðŸ“Œ Added node_id from extract_info step to artifact');
              } else {
                core.warning('âš ï¸ No node_id available in classification or extract_info outputs');
              }
            }
            
            // Write to file
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            core.info('ðŸ’¾ Created classification artifact with the following data:');
            core.info(`- Item type: ${artifactData.item?.type || 'Unknown'}`);
            core.info(`- Item number: ${artifactData.item?.number || 'Unknown'}`);
            core.info(`- Node ID present: ${artifactData.item?.node_id ? 'Yes' : 'No'}`);
            
            core.setOutput('artifact_name', artifactName);
            
      - name: Upload Classification Artifact
        if: steps.extract_info.outputs.has_item == 'true' && steps.create_artifact.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 1

  # Project integration job remains the same...
  project_integration:
    name: "ðŸ“‹ Project Integration"
    needs: classify
    if: needs.classify.outputs.has_item == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Classification Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}
          
      - name: Debug Classification Data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              const data = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('ðŸ“Š Classification Data Debug:');
              core.info(`- File exists: Yes`);
              core.info(`- Has metadata: ${data.metadata ? 'Yes' : 'No'}`);
              core.info(`- Has item: ${data.item ? 'Yes' : 'No'}`);
              
              if (data.item) {
                core.info(`- Item number: ${data.item.number || 'Not found'}`);
                core.info(`- Item type: ${data.item.type || 'Not found'}`);
                core.info(`- Node ID: ${data.item.node_id || 'Not found'}`);
              }
              
              if (!data.item?.node_id) {
                // Try to fetch node_id directly as fallback
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                const number = data.item?.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
                const isPR = data.item?.type === 'pull_request' || '${{ needs.classify.outputs.item_type }}' === 'pull_request';
                
                if (number) {
                  core.info(`ðŸ”„ Attempting to fetch node_id for ${isPR ? 'PR' : 'Issue'} #${number} as fallback...`);
                  
                  try {
                    if (isPR) {
                      const pr = await github.rest.pulls.get({owner, repo, pull_number: number});
                      data.item.node_id = pr.data.node_id;
                    } else {
                      const issue = await github.rest.issues.get({owner, repo, issue_number: number});
                      data.item.node_id = issue.data.node_id;
                    }
                    
                    if (data.item.node_id) {
                      core.info(`âœ… Successfully retrieved node_id: ${data.item.node_id}`);
                      fs.writeFileSync('classification.json', JSON.stringify(data, null, 2));
                    }
                  } catch (e) {
                    core.warning(`âŒ Failed to fetch node_id: ${e.message}`);
                  }
                }
              }
            } catch (e) {
              core.error(`âŒ Failed to parse classification.json: ${e.message}`);
            }

      - name: Add to Project with Classification
        uses: actions/github-script@v7
        env:
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
          PROJECT_TITLE: ${{ github.event.inputs.project_title || env.DEFAULT_PROJECT_TITLE }}
          NODE_ID_FALLBACK: ${{ needs.classify.outputs.node_id }}
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const isDryRun = !process.env.GH_PROJECT_TOKEN || '${{ github.event.inputs.dry_run }}' === 'true';
            const projectTitle = process.env.PROJECT_TITLE || 'MerajutASA Program Board';
            const nodeIdFallback = process.env.NODE_ID_FALLBACK;
            
            // Load classification data
            let classification;
            try {
              classification = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('âœ… Loaded classification data');
            } catch (e) {
              core.setFailed(`Failed to load classification data: ${e.message}`);
              return;
            }
            
            // Extract key information
            const item = classification.item || {};
            const classifications = classification.classifications || {};
            const labels = classification.labels?.final || [];
            
            const itemType = item.type || '${{ needs.classify.outputs.item_type }}';
            const itemNumber = item.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
            const isPR = itemType === 'pull_request';
            
            // Get node_id from classification data or fallback
            let contentId = item.node_id || nodeIdFallback;
            
            // If still no node_id, fetch it directly
            if (!contentId) {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              try {
                core.info(`ðŸ”„ No node_id found in data, fetching directly for ${isPR ? 'PR' : 'Issue'} #${itemNumber}...`);
                
                if (isPR) {
                  const pr = await github.rest.pulls.get({owner, repo, pull_number: itemNumber});
                  contentId = pr.data.node_id;
                } else {
                  const issue = await github.rest.issues.get({owner, repo, issue_number: itemNumber});
                  contentId = issue.data.node_id;
                }
                
                if (contentId) {
                  core.info(`âœ… Successfully retrieved node_id: ${contentId}`);
                }
              } catch (e) {
                core.setFailed(`Failed to fetch node_id: ${e.message}`);
                return;
              }
            }
            
            if (!contentId) {
              core.setFailed('Missing node_id. Cannot add to project.');
              return;
            }
            
            // Project configuration
            const ownerLogin = context.repo.owner;
            
            core.info(`ðŸŽ¯ Processing ${isPR ? 'PR' : 'Issue'} #${itemNumber} for project "${projectTitle}"`);
            core.info(`Using node ID: ${contentId}`);
            
            if (isDryRun) {
              core.info('ðŸ§ª DRY RUN MODE: Will simulate but not make actual changes');
              // Write summary for dry run
              fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                timestamp: new Date().toISOString(),
                dry_run: true,
                project: projectTitle,
                item: {
                  type: itemType,
                  number: itemNumber,
                  title: item.title,
                  node_id: contentId,
                  classifications: classifications
                }
              }, null, 2));
              return;
            }
            
            // Project lookup
            const projectQuery = `
              query($owner: String!) {
                repositoryOwner(login: $owner) {
                  id
                  login
                  ... on User {
                    projectsV2(first: 20) {
                      nodes {
                        id title url public
                        fields(first: 50) {
                          nodes {
                            __typename
                            ... on ProjectV2FieldCommon { id name dataType }
                            ... on ProjectV2SingleSelectField { 
                              id name dataType 
                              options { id name color description } 
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            try {
              const resp = await github.graphql(projectQuery, { owner: ownerLogin });
              const nodes = resp.repositoryOwner?.projectsV2?.nodes || [];
              
              const project = nodes.find(p => p.title === projectTitle)
                    || nodes.find(p => p.title.toLowerCase() === projectTitle.toLowerCase())
                    || nodes.find(p => p.title === 'MerajutASA Program Board');
                    
              if (!project) {
                core.warning(`âŒ Project "${projectTitle}" not found in ${ownerLogin}'s account`);
                core.info('ðŸ’¡ Available projects:');
                for (const p of nodes) {
                  core.info(`- ${p.title}`);
                }
                return;
              }
              
              core.info(`âœ… Using project: ${project.title} (${project.url || 'N/A'})`);
              
              // The rest of the project integration logic follows
              const projectId = project.id;
              
              // Check if already in project
              const itemQuery = `
                query($projectId: ID!, $first: Int = 100) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: $first) {
                        nodes {
                          id
                          content {
                            ... on Issue { id number repository { nameWithOwner } }
                            ... on PullRequest { id number repository { nameWithOwner } }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const itemsResp = await github.graphql(itemQuery, { projectId });
              const items = itemsResp.node.items.nodes;
              
              const repoFullName = `${context.repo.owner}/${context.repo.repo}`;
              const existingItem = items.find(i => 
                i.content && 
                i.content.number === itemNumber && 
                i.content.repository?.nameWithOwner === repoFullName
              );
              
              let itemId;
              if (existingItem) {
                itemId = existingItem.id;
                core.info(`ðŸ”„ Item already exists in project, ID: ${itemId}`);
              } else {
                // Add item to project
                core.info(`âž• Adding ${isPR ? 'PR' : 'Issue'} #${itemNumber} to project`);
                
                try {
                  const addMutation = `
                    mutation($projectId: ID!, $contentId: ID!) { 
                      addProjectV2ItemById(input: {
                        projectId: $projectId, 
                        contentId: $contentId
                      }) { 
                        item { id } 
                      } 
                    }
                  `;
                  
                  core.info(`Using contentId: ${contentId}`);
                  
                  const addResult = await github.graphql(addMutation, { 
                    projectId, 
                    contentId 
                  });
                  
                  itemId = addResult.addProjectV2ItemById.item.id;
                  core.info(`âœ… Added item with ID: ${itemId}`);
                  
                  // Write a summary 
                  fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                    timestamp: new Date().toISOString(),
                    project: project.title,
                    item: {
                      type: itemType,
                      number: itemNumber,
                      added_to_project: true,
                    },
                    classifications: classifications
                  }, null, 2));
                  
                } catch (e) {
                  core.setFailed(`Failed to add item to project: ${e.message}`);
                  fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                    timestamp: new Date().toISOString(),
                    project: project.title,
                    error: e.message,
                    item: {
                      type: itemType,
                      number: itemNumber,
                      added_to_project: false,
                    }
                  }, null, 2));
                }
              }
            } catch (error) {
              core.setFailed(`Project lookup failed: ${error.message}`);
              fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                timestamp: new Date().toISOString(),
                error: error.message
              }, null, 2));
            }

      - name: Upload Integration Summary
        uses: actions/upload-artifact@v4
        with:
          name: project-integration-summary
          path: project-integration-summary.json
          retention-days: 7
          if-no-files-found: ignore