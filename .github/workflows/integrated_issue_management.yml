name: Integrated Issue Management (Personal Account)

# Workflow that combines auto-labeling and project management
# Created: 2025-08-20
# Author: Andhika-Rey
# Version: 1.2.0

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      project_title:
        description: 'Project title to target'
        required: false
        default: "MerajutASA Program Board"
      area:
        description: 'Override area classification'
        required: false
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  DEFAULT_PROJECT_TITLE: "MerajutASA Program Board"
  WORKFLOW_VERSION: "1.2.0"
  CREATED_AT: "2025-08-20"
  UPDATED_AT: "2025-08-20 04:46:18"
  CREATED_BY: "Andhika-Rey"

jobs:
  # Step 1: Extract information and classify the issue/PR
  classify:
    name: "🔍 Extract & Classify"
    runs-on: ubuntu-latest
    outputs:
      item_number: ${{ steps.extract_info.outputs.item_number }}
      item_type: ${{ steps.extract_info.outputs.item_type }}
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      has_item: ${{ steps.extract_info.outputs.has_item }}
      node_id: ${{ steps.extract_info.outputs.node_id }}
    
    steps:
      - name: Extract Item Information
        id: extract_info
        uses: actions/github-script@v7
        with:
          script: |
            const { eventName, payload, repo } = context;
            const owner = repo.owner;
            const repoName = repo.repo;
            
            let isPR = eventName === 'pull_request';
            let number = null;
            let hasItem = false;
            let nodeId = null;
            
            // Handle different event types to extract item number
            if (eventName === 'pull_request') {
              number = payload.pull_request.number;
              nodeId = payload.pull_request.node_id;
              hasItem = true;
            } else if ((eventName === 'issues' || eventName === 'issue_comment') && payload.issue) {
              number = payload.issue.number;
              nodeId = payload.issue.node_id;
              isPR = !!payload.issue.pull_request;
              hasItem = true;
            } else if (eventName === 'workflow_dispatch' && payload.inputs && payload.inputs.number) {
              number = parseInt(payload.inputs.number, 10);
              if (!isNaN(number)) {
                // Determine if number refers to a PR
                try {
                  const pr = await github.rest.pulls.get({
                    owner,
                    repo: repoName,
                    pull_number: number
                  });
                  isPR = true;
                  nodeId = pr.data.node_id;
                  hasItem = true;
                } catch (e) {
                  try {
                    const issue = await github.rest.issues.get({
                      owner,
                      repo: repoName,
                      issue_number: number
                    });
                    isPR = false;
                    nodeId = issue.data.node_id;
                    hasItem = true;
                  } catch (e) {
                    core.warning(`Item #${number} not found as issue or PR`);
                    hasItem = false;
                  }
                }
              }
            }
            
            if (hasItem) {
              core.info(`✅ Found ${isPR ? 'PR' : 'Issue'} #${number}`);
              if (nodeId) {
                core.info(`📌 Node ID: ${nodeId}`);
              } else {
                core.warning('⚠️ No Node ID found, will try to fetch it in next step');
              }
            } else {
              core.warning('⚠️ No valid issue/PR number found in this event');
            }
            
            core.setOutput('item_number', number ? number.toString() : '');
            core.setOutput('item_type', isPR ? 'pull_request' : 'issue');
            core.setOutput('has_item', hasItem ? 'true' : 'false');
            if (nodeId) {
              core.setOutput('node_id', nodeId);
            }

      # Skip the rest if no valid item was found
      - name: Check for valid item
        id: check_item
        if: steps.extract_info.outputs.has_item != 'true'
        run: |
          echo "::notice::No valid issue or PR found to process"
          exit 0

      - name: Fetch Item Details
        id: fetch_details
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
            const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            let title = '', body = '', labels = [], milestoneTitle = '';
            let prState = null, isDraft = false, merged = false, issueState = null;
            let item = null;
            let nodeId = '${{ steps.extract_info.outputs.node_id }}';
            let assignees = [], comments = 0, commentsData = [];
            let createdAt, updatedAt;
            let author = null;
            let files = [], additions = 0, deletions = 0, changes = 0;
            
            try {
              if (isPR) {
                const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                item = pr;
                title = pr.title || '';
                body = pr.body || '';
                labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = pr.milestone?.title || '';
                prState = typeof pr.state === 'string' ? pr.state.toLowerCase() : null;
                isDraft = !!pr.draft;
                merged = !!pr.merged;
                if (!nodeId) nodeId = pr.node_id;
                assignees = pr.assignees?.map(a => a.login) || [];
                author = pr.user?.login;
                createdAt = pr.created_at;
                updatedAt = pr.updated_at;
                
                // Get PR comments
                const prComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = prComments.data.length;
                commentsData = prComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                }));
                
                // Get PR review comments
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner, repo, pull_number: number, per_page: 100
                });
                comments += reviewComments.data.length;
                commentsData.push(...reviewComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login,
                  created_at: c.created_at 
                })));
                
                // Get PR files
                const perPage = 100;
                let page = 1;
                while (true) {
                  try {
                    const resp = await github.rest.pulls.listFiles({ 
                      owner, repo, pull_number: number, per_page: perPage, page 
                    });
                    files.push(...resp.data);
                    if (resp.data.length < perPage) break;
                    page += 1;
                  } catch (e) {
                    core.warning(`Failed to get PR files page ${page}: ${e.message}`);
                    break;
                  }
                }
                additions = files.reduce((s, f) => s + (f.additions || 0), 0);
                deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
                changes = files.reduce((s, f) => s + (f.changes || 0), 0);
              } else {
                const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                item = issue;
                title = issue.title || '';
                body = issue.body || '';
                labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                milestoneTitle = issue.milestone?.title || '';
                issueState = typeof issue.state === 'string' ? issue.state.toLowerCase() : null;
                if (!nodeId) nodeId = issue.node_id;
                assignees = issue.assignees?.map(a => a.login) || [];
                author = issue.user?.login;
                createdAt = issue.created_at;
                updatedAt = issue.updated_at;
                
                // Get issue comments
                const issueComments = await github.rest.issues.listComments({
                  owner, repo, issue_number: number, per_page: 100
                });
                comments = issueComments.data.length;
                commentsData = issueComments.data.map(c => ({ 
                  body: c.body, 
                  user: c.user?.login, 
                  created_at: c.created_at
                }));
              }
              
              core.info(`📝 Title: ${title}`);
              core.info(`👤 Author: ${author || 'Unknown'}`);
              core.info(`💬 Comments: ${comments}`);
              core.info(`📅 Created: ${createdAt}`);
              
              if (isPR) {
                core.info(`📊 PR Stats: +${additions} -${deletions} changes: ${changes}`);
              }
              
            } catch (e) {
              core.warning(`⚠️ Error fetching details: ${e.message}`);
            }
            
            // Save to outputs for next steps
            return {
              item: {
                number,
                title,
                body,
                isPR,
                labels,
                nodeId,
                milestoneTitle,
                state: isPR ? prState : issueState,
                isDraft,
                merged,
                assignees,
                author,
                createdAt,
                updatedAt,
                comments,
                commentsData,
                url: isPR ? `https://github.com/${owner}/${repo}/pull/${number}` : `https://github.com/${owner}/${repo}/issues/${number}`
              },
              files: {
                list: files.map(f => ({ filename: f.filename, additions: f.additions, deletions: f.deletions })),
                stats: { additions, deletions, changes }
              }
            };

      - name: Analyze and Apply Labels
        id: auto_labeler
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Enhanced classification function with improved content analysis
            async function classifyItem() {
              const isPR = '${{ steps.extract_info.outputs.item_type }}' === 'pull_request';
              const number = parseInt('${{ steps.extract_info.outputs.item_number }}', 10);
              const nodeId = '${{ steps.extract_info.outputs.node_id }}';
              const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
              const areaOverride = '${{ github.event.inputs.area }}';
              
              // Get fetch_details step result
              let itemDetails;
              try {
                const detailsOutput = ${{ toJSON(steps.fetch_details.outputs.result) }};
                core.info(`Received fetch_details output: ${typeof detailsOutput}`);
                
                // Parse the details if it's a string
                if (typeof detailsOutput === 'string') {
                  itemDetails = JSON.parse(detailsOutput);
                } else {
                  itemDetails = detailsOutput;
                }
                
                // Validate itemDetails structure
                if (!itemDetails || !itemDetails.item) {
                  core.warning('Invalid or missing itemDetails structure!');
                  // Create fallback structure
                  itemDetails = { 
                    item: { 
                      title: '', 
                      body: '', 
                      labels: [],
                      nodeId: nodeId,
                      number: number,
                      isPR: isPR 
                    }, 
                    files: { list: [], stats: { additions: 0, deletions: 0, changes: 0 } } 
                  };
                  
                  // Fetch directly as fallback
                  core.info('Fetching issue/PR details directly as fallback...');
                  const owner = context.repo.owner;
                  const repo = context.repo.repo;
                  
                  if (isPR) {
                    const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
                    itemDetails.item.title = pr.title || '';
                    itemDetails.item.body = pr.body || '';
                    itemDetails.item.labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                    itemDetails.item.nodeId = pr.node_id;
                  } else {
                    const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
                    itemDetails.item.title = issue.title || '';
                    itemDetails.item.body = issue.body || '';
                    itemDetails.item.labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
                    itemDetails.item.nodeId = issue.node_id;
                  }
                }
              } catch (error) {
                core.warning(`Error processing item details: ${error.message}`);
                // Use minimal fallback data
                itemDetails = { 
                  item: { 
                    title: 'Unknown Title', 
                    body: '', 
                    labels: [],
                    nodeId: nodeId,
                    number: number,
                    isPR: isPR 
                  },
                  files: { list: [], stats: { additions: 0, deletions: 0, changes: 0 } } 
                };
              }
              
              // Prevent relabel loops when the actor is the bot itself
              if ((context.eventName === 'issues' && ['labeled','unlabeled'].includes(context.payload.action)) ||
                  (context.eventName === 'pull_request' && ['labeled','unlabeled'].includes(context.payload.action))) {
                if (context.actor === 'github-actions[bot]') {
                  core.info('Skip to prevent relabel loop (actor is github-actions[bot]).');
                  return { skipped: true, reason: 'bot_actor' };
                }
              }
              
              // Extract item details - with safe accessors
              const item = itemDetails.item || {};
              const files = itemDetails.files || { list: [], stats: { additions: 0, deletions: 0, changes: 0 } };
              
              // Extract all the details we need - with safe accessors
              const title = item.title || '';
              const body = item.body || '';
              const labels = item.labels || [];
              const milestoneTitle = item.milestoneTitle || '';
              const assignees = item.assignees || [];
              const author = item.author;
              const commentsData = item.commentsData || [];
              
              core.info(`Processing: "${title}" (${isPR ? 'PR' : 'Issue'} #${number})`);
              
              // Enhanced content analysis with multiple approaches
              const allContent = [
                title,
                body,
                ...(commentsData || []).map(c => c.body)
              ].filter(Boolean).join('\n').toLowerCase();
              
              const filePaths = (files.list || []).map(f => (f.filename || '').toLowerCase());
              const additions = files.stats?.additions || 0;
              const deletions = files.stats?.deletions || 0;
              const changes = files.stats?.changes || 0;
              
              // Utility functions
              const hasAny = (s, arr) => arr.some(k => s.includes(k.toLowerCase()));
              const hasAll = (s, arr) => arr.every(k => s.includes(k.toLowerCase()));
              const pathHasAny = (arr) => filePaths.some(p => arr.some(k => p.includes(k.toLowerCase())));
              const countOccurrences = (s, term) => {
                const regex = new RegExp(term, 'gi');
                return (s.match(regex) || []).length;
              };
              
              // ===== AREA CLASSIFICATION (IMPROVED) =====
              const areas = [];
              const areaConfidenceScores = {};
              const areaDetails = {};
              
              // Define area detectors
              const areaDetectors = [
                {
                  name: 'security-layer',
                  terms: ['security', 'auth', 'authentication', 'authorization', 'login', 'password', 'credential', 'oauth', 'vulnerability'],
                  files: ['security', 'auth', 'login', 'password', 'credentials'],
                  threshold: 0.6
                },
                {
                  name: 'monitoring-observability',
                  terms: ['monitoring', 'metrics', 'grafana', 'prometheus', 'logging', 'trace', 'observability', 'analytics'],
                  files: ['monitor', 'metrics', 'log', 'trace'],
                  threshold: 0.6
                },
                {
                  name: 'performance-optimization',
                  terms: ['performance', 'optimize', 'optimization', 'speed', 'fast', 'slow', 'latency', 'throughput', 'cache'],
                  files: ['performance', 'optimize', 'cache', 'speed'],
                  threshold: 0.6
                },
                {
                  name: 'container-orchestration',
                  terms: ['kubernetes', 'k8s', 'container', 'docker', 'pod', 'cluster', 'orchestration', 'helm', 'chart'],
                  files: ['k8s', 'kubernetes', 'docker', 'container', 'pod'],
                  threshold: 0.6
                },
                {
                  name: 'cicd-pipeline',
                  terms: ['ci/cd', 'pipeline', 'continuous integration', 'continuous delivery', 'github actions', 'jenkins', 'travis'],
                  files: ['pipeline', 'ci', 'cd', 'github/workflows', 'github-workflow'],
                  threshold: 0.6
                },
                {
                  name: 'data-management',
                  terms: ['database', 'data', 'sql', 'nosql', 'mongodb', 'postgres', 'mysql', 'redis', 'storage', 'etl', 'backup'],
                  files: ['database', 'db', 'sql', 'data', 'backup', 'storage'],
                  threshold: 0.6
                },
                {
                  name: 'api-gateway-services',
                  terms: ['api', 'gateway', 'service', 'microservice', 'rest', 'graphql', 'endpoint', 'route'],
                  files: ['api', 'gateway', 'service', 'endpoint', 'controller'],
                  threshold: 0.6
                },
                {
                  name: 'docs',
                  terms: ['documentation', 'doc', 'readme', 'wiki', 'guide', 'tutorial', 'manual'],
                  files: ['docs', 'documentation', 'wiki', 'readme', '.md'],
                  threshold: 0.6
                },
                {
                  name: 'ui-components',
                  terms: ['ui', 'ux', 'user interface', 'design', 'layout', 'css', 'html', 'frontend', 'react', 'vue', 'angular'],
                  files: ['ui', 'frontend', 'css', 'html', 'jsx', 'tsx', 'vue'],
                  threshold: 0.6
                },
                {
                  name: 'compliance',
                  terms: ['compliance', 'regulation', 'gdpr', 'hipaa', 'sox', 'pci', 'standard', 'audit', 'certification', 'conform'],
                  files: ['compliance', 'regulation', 'audit', 'standard', 'certif'],
                  threshold: 0.5
                },
                {
                  name: 'integration',
                  terms: ['integration', 'connect', 'connector', 'webhook', 'interface', 'bridge', 'middleware', 'sync'],
                  files: ['integration', 'connector', 'webhook', 'middleware', 'bridge', 'interface'],
                  threshold: 0.6
                },
                {
                  name: 'infrastructure',
                  terms: ['infrastructure', 'terraform', 'aws', 'azure', 'gcp', 'cloud', 'network', 'server', 'provision'],
                  files: ['terraform', 'cloud', 'infra', 'provision', 'network', 'server'],
                  threshold: 0.6
                },
                {
                  name: 'analytics',
                  terms: ['analytics', 'statistics', 'reporting', 'dashboard', 'chart', 'graph', 'data visualization', 'bi'],
                  files: ['analytics', 'report', 'dashboard', 'stats', 'visualization'],
                  threshold: 0.6
                }
              ];
              
              // Detect Phase from title
              const phaseRegex = /phase\s*(\d+)\s*(?:week|w)?\s*(\d+)?/i;
              const phaseMatch = title.match(phaseRegex) || body.match(phaseRegex);
              let phase = null;
              
              if (phaseMatch) {
                const phaseNum = phaseMatch[1];
                const weekNum = phaseMatch[2];
                
                if (weekNum) {
                  phase = `phase:${phaseNum}-week-${weekNum}`;
                } else {
                  phase = `phase:${phaseNum}`;
                }
                
                core.info(`📝 Detected phase information: ${phase}`);
              }
              
              // Special cases from title patterns
              if (title.match(/component completion|completion/i)) {
                areaConfidenceScores['compliance'] = 0.8;
                areaDetails['compliance'] = 'Identified from component completion task in title';
              }
              
              if (title.match(/integration|flow completion|validate/i)) {
                areaConfidenceScores['integration'] = 0.8;
                areaDetails['integration'] = 'Identified from integration flow mentioned in title';
              }
              
              if (title.match(/infra|infrastructure|script|exit code/i)) {
                areaConfidenceScores['infrastructure'] = 0.7;
                areaDetails['infrastructure'] = 'Identified from infrastructure or script references in title';
              }
              
              // Analyze content for each area
              for (const detector of areaDetectors) {
                let score = 0;
                let details = [];
                
                // Check term occurrences in content
                for (const term of detector.terms) {
                  const count = countOccurrences(allContent, term);
                  if (count > 0) {
                    score += Math.min(0.2 + (count * 0.1), 0.5); // Cap at 0.5 per term
                    details.push(`Found "${term}" ${count} time(s) in content`);
                  }
                }
                
                // Check file paths for matches
                if (filePaths.length > 0) {
                  for (const filePattern of detector.files) {
                    const matchingFiles = filePaths.filter(p => p.includes(filePattern));
                    if (matchingFiles.length > 0) {
                      score += Math.min(0.3 + (matchingFiles.length * 0.05), 0.6);
                      details.push(`Found ${matchingFiles.length} file(s) matching "${filePattern}"`);
                    }
                  }
                }
                
                // Special case: directly mentioned area in title/body (strong signal)
                if (title.toLowerCase().includes(detector.name) || 
                    allContent.includes(`area:${detector.name}`) ||
                    allContent.includes(`area: ${detector.name}`)) {
                  score += 0.8;
                  details.push(`Direct mention of area "${detector.name}" in content`);
                }
                
                // Record if threshold met
                if (score >= detector.threshold) {
                  areaConfidenceScores[detector.name] = parseFloat(score.toFixed(2));
                  areaDetails[detector.name] = details.join('; ');
                }
              }
              
              // Apply override if provided
              if (areaOverride) {
                areaConfidenceScores[areaOverride] = 1.0;
                areaDetails[areaOverride] = 'Manual override applied';
                core.info(`🔧 Manual area override applied: ${areaOverride}`);
              }
              
              // Select areas that meet threshold
              for (const [area, score] of Object.entries(areaConfidenceScores)) {
                if (score >= 0.5) {
                  areas.push(`area:${area}`);
                }
              }
              
              // If no areas detected, use default based on content
              if (areas.length === 0) {
                if (title.toLowerCase().includes('test')) {
                  areas.push('area:monitoring-observability');
                  areaConfidenceScores['monitoring-observability'] = 0.6;
                  areaDetails['monitoring-observability'] = 'Default: Test-related issue';
                } else {
                  areas.push('area:api-gateway-services');
                  areaConfidenceScores['api-gateway-services'] = 0.5;
                  areaDetails['api-gateway-services'] = 'Default: No specific area detected';
                }
              }
              
              // Log area classifications
              core.info('📊 Area classification results:');
              for (const [area, score] of Object.entries(areaConfidenceScores)) {
                core.info(`  - ${area}: ${score} - ${areaDetails[area] || 'No details'}`);
              }
              
              // ===== PRIORITY CLASSIFICATION =====
              let priority = null;
              if (title.toLowerCase().includes('urgent') || 
                  title.toLowerCase().includes('critical') || 
                  title.toLowerCase().includes('p0') || 
                  body?.toLowerCase().includes('urgent') || 
                  body?.toLowerCase().includes('p0')) {
                priority = 'p0';
              } else if (title.toLowerCase().includes('high priority') || 
                         title.toLowerCase().includes('p1') || 
                         body?.toLowerCase().includes('high priority') || 
                         body?.toLowerCase().includes('p1') ||
                         title.toLowerCase().includes('phase 2')) {
                priority = 'p1';
              } else if (title.toLowerCase().includes('medium priority') || 
                         title.toLowerCase().includes('p2') || 
                         body?.toLowerCase().includes('medium priority')) {
                priority = 'p2';
              } else {
                priority = 'p3';
              }
              
              // ===== RISK CLASSIFICATION =====
              let risk = null;
              if (title.toLowerCase().includes('high risk') || 
                  body?.toLowerCase().includes('high risk') || 
                  areaConfidenceScores['security-layer'] > 0.7) {
                risk = 'risk:high';
              } else if (title.toLowerCase().includes('medium risk') || 
                         body?.toLowerCase().includes('medium risk') || 
                         areaConfidenceScores['compliance'] > 0.7 || 
                         title.includes('Phase 2')) {
                risk = 'risk:medium';
              } else {
                risk = 'risk:low';
              }
              
              // ===== STATUS CLASSIFICATION =====
              let status = null;
              const hasStatusLabel = labels.some(l => l.startsWith('status:'));
              
              if (isPR) {
                if (item.merged) {
                  status = 'status:done';
                } else if (item.state === 'closed') {
                  status = 'status:done';
                } else if (context.payload.action === 'ready_for_review' || !item.isDraft) {
                  status = 'status:in-review';
                } else {
                  status = 'status:in-progress';
                }
              } else {
                if (item.state === 'closed') {
                  status = 'status:done';
                } else if (hasStatusLabel) {
                  // Keep existing status label if any
                  const existingStatus = labels.find(l => l.startsWith('status:'));
                  if (existingStatus) {
                    status = existingStatus;
                  } else {
                    status = 'status:todo';
                  }
                } else if (assignees.length > 0) {
                  status = 'status:in-progress'; // Assigned issues are in progress
                } else {
                  status = 'status:todo';
                }
              }
              
              // ===== SIZE CLASSIFICATION =====
              let size = null;
              if (isPR) {
                const totalChanges = additions + deletions;
                if (totalChanges <= 10) {
                  size = 'size:xs';
                } else if (totalChanges <= 100) {
                  size = 'size:small';
                } else if (totalChanges <= 250) {
                  size = 'size:medium';
                } else if (totalChanges <= 500) {
                  size = 'size:large';
                } else {
                  size = 'size:very-large';
                }
              } else {
                // For issues, size is more subjective
                // Use title length and task description as heuristics
                if (title.includes('component') || title.includes('completion')) {
                  size = 'size:medium';
                } else if (body && body.length > 1000) {
                  size = 'size:large';
                } else if (body && body.length > 500) {
                  size = 'size:medium';
                } else {
                  size = 'size:small';
                }
              }
              
              // ===== TEAM CLASSIFICATION =====
              let team = null;
              // Determine team based on areas
              if (areas.includes('area:security-layer')) {
                team = 'team:security';
              } else if (areas.includes('area:container-orchestration') || 
                         areas.includes('area:cicd-pipeline') || 
                         areas.includes('area:infrastructure')) {
                team = 'team:devops';
              } else if (areas.includes('area:monitoring-observability') || 
                         areas.includes('area:analytics')) {
                team = 'team:qa';
              } else if (areas.includes('area:ui-components')) {
                team = 'team:frontend';
              } else {
                team = 'team:backend-dev';
              }
              
              // ===== HEALTH CLASSIFICATION =====
              let health = 'health:50-74';
              
              // Apply labels
              const existing = new Set(labels);
              const toAdd = new Set();
              const toRemove = new Set();
              
              // Remove old conflicting labels before adding new ones
              for (const label of existing) {
                if (areas.some(a => a.startsWith('area:')) && label.startsWith('area:') && !areas.includes(label)) {
                  toRemove.add(label);
                }
                if (risk && label.startsWith('risk:') && label !== risk) {
                  toRemove.add(label);
                }
                if (status && label.startsWith('status:') && label !== status) {
                  toRemove.add(label);
                }
                if (size && label.startsWith('size:') && label !== size) {
                  toRemove.add(label);
                }
                if (team && label.startsWith('team:') && label !== team) {
                  toRemove.add(label);
                }
              }
              
              // Add new labels
              for (const area of areas) {
                if (!existing.has(area)) toAdd.add(area);
              }
              if (phase && !existing.has(phase)) toAdd.add(phase);
              if (risk && !existing.has(risk)) toAdd.add(risk);
              if (status && !existing.has(status)) toAdd.add(status);
              if (size && !existing.has(size)) toAdd.add(size);
              if (team && !existing.has(team)) toAdd.add(team);
              if (priority && !existing.has(priority)) toAdd.add(priority);
              if (!existing.has(health)) toAdd.add(health);
              
              const addList = Array.from(toAdd);
              const removeList = Array.from(toRemove);
              
              // Record classifications with confidence scores
              const classifications = {
                areas: areas.map(a => ({
                  value: a.split(':')[1],
                  confidence: areaConfidenceScores[a.split(':')[1]] || 0.5,
                  reason: areaDetails[a.split(':')[1]] || 'Unknown'
                })),
                risk: risk ? { 
                  value: risk.split(':')[1],
                  confidence: 0.8,
                  reason: 'Determined from content and area analysis'
                } : null,
                status: status ? {
                  value: status.split(':')[1],
                  confidence: 0.9,
                  reason: isPR ? 'Based on PR state' : 'Based on issue state and assignment'
                } : null,
                size: size ? {
                  value: size.split(':')[1],
                  confidence: 0.8,
                  reason: isPR ? 'Based on code changes' : 'Based on content complexity'
                } : null,
                team: team ? {
                  value: team.split(':')[1],
                  confidence: 0.8,
                  reason: 'Derived from area classification'
                } : null,
                phase: phase ? {
                  value: phase.split(':')[1],
                  confidence: 0.9,
                  reason: 'Extracted from title/body'
                } : null,
                priority: priority ? {
                  value: priority,
                  confidence: 0.8,
                  reason: 'Determined from content analysis and phase'
                } : null,
                health: {
                  value: health.split(':')[1],
                  confidence: 0.7,
                  reason: 'Default health classification'
                }
              };
              
              // Dry-run or apply labels
              if (dryRun) {
                core.info('🧪 DRY RUN: Label changes preview');
                core.info(`Would add: ${addList.join(', ') || 'None'}`);
                core.info(`Would remove: ${removeList.join(', ') || 'None'}`);
                return {
                  dryRun: true,
                  item: {
                    type: isPR ? 'pull_request' : 'issue',
                    number: number,
                    title: title,
                    node_id: nodeId,
                    author: author
                  },
                  labels: { existing: Array.from(existing), toAdd: addList, toRemove: removeList },
                  classifications: classifications
                };
              }
              
              // Apply labels
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              // Apply removals first
              for (const l of removeList) {
                try {
                  await github.rest.issues.removeLabel({ 
                    owner, repo, issue_number: number, name: l 
                  });
                  core.info(`🗑️ Removed label: ${l}`);
                } catch (e) {
                  if (e.status !== 404) core.warning(`Failed to remove label ${l}: ${e.message}`);
                }
              }
              
              // Apply additions
              if (addList.length) {
                try {
                  await github.rest.issues.addLabels({ 
                    owner, repo, issue_number: number, labels: addList 
                  });
                  core.info(`🏷️ Added labels: ${addList.join(', ')}`);
                } catch (e) {
                  core.warning(`Failed to add labels: ${e.message}`);
                }
              } else {
                core.info('✓ No new labels to add');
              }
              
              const finalLabels = [...labels.filter(l => !removeList.includes(l)), ...addList];
              
              // Add a comment explaining classifications if changes were made
              if (addList.length > 0 || removeList.length > 0) {
                try {
                  const commentBody = `## 🤖 Classification Analysis

I've analyzed this ${isPR ? 'pull request' : 'issue'} and made the following classifications:

${areas.map(area => `### ${area.replace('area:', 'Area: ')}
- Confidence: ${(areaConfidenceScores[area.split(':')[1]] * 100).toFixed(0)}%
- Reason: ${areaDetails[area.split(':')[1]] || 'No specific details'}`).join('\n\n')}

### Additional Classifications:
- Risk: **${risk.split(':')[1]}**
- Status: **${status.split(':')[1]}**
- Size: **${size.split(':')[1]}**
- Team: **${team.split(':')[1]}**
${phase ? `- Phase: **${phase.split(':')[1]}**` : ''}
${priority ? `- Priority: **${priority}**` : ''}

*Labels have been updated accordingly.*`;

                  if (!isPR) {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: number,
                      body: commentBody
                    });
                    core.info('💬 Added explanation comment');
                  }
                } catch (e) {
                  core.warning(`Failed to add comment: ${e.message}`);
                }
              }
              
              return {
                item: {
                  type: isPR ? 'pull_request' : 'issue',
                  number: number,
                  title: title,
                  body: body,
                  state: item.state,
                  isPR: isPR,
                  node_id: nodeId,
                  author: author,
                  url: item.url
                },
                labels: { final: finalLabels, added: addList, removed: removeList },
                classifications: classifications
              };
            }
            
            // Execute the classification
            return await classifyItem();

      - name: Create Classification Artifact
        id: create_artifact
        if: steps.extract_info.outputs.has_item == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            
            // Get the classification results from the previous step
            const result = ${{ toJSON(steps.auto_labeler.outputs.result) }};
            
            // Add metadata
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                updated_at: process.env.UPDATED_AT,
                version: process.env.WORKFLOW_VERSION,
                user: context.actor,
                event_type: context.eventName,
                action: context.payload.action || 'manual',
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`
              },
              ...result
            };
            
            // Ensure node_id is present
            if (!artifactData.item || !artifactData.item.node_id) {
              if ('${{ steps.extract_info.outputs.node_id }}') {
                if (!artifactData.item) artifactData.item = {};
                artifactData.item.node_id = '${{ steps.extract_info.outputs.node_id }}';
                core.info('📌 Added node_id from extract_info step to artifact');
              } else {
                core.warning('⚠️ No node_id available in classification or extract_info outputs');
              }
            }
            
            // Write to file
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            core.info('💾 Created classification artifact with the following data:');
            core.info(`- Item type: ${artifactData.item?.type || 'Unknown'}`);
            core.info(`- Item number: ${artifactData.item?.number || 'Unknown'}`);
            core.info(`- Node ID present: ${artifactData.item?.node_id ? 'Yes' : 'No'}`);
            
            core.setOutput('artifact_name', artifactName);
            
      - name: Upload Classification Artifact
        if: steps.extract_info.outputs.has_item == 'true' && steps.create_artifact.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 1

  # Project integration job remains the same...
  project_integration:
    name: "📋 Project Integration"
    needs: classify
    if: needs.classify.outputs.has_item == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Classification Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}
          
      - name: Debug Classification Data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              const data = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('📊 Classification Data Debug:');
              core.info(`- File exists: Yes`);
              core.info(`- Has metadata: ${data.metadata ? 'Yes' : 'No'}`);
              core.info(`- Has item: ${data.item ? 'Yes' : 'No'}`);
              
              if (data.item) {
                core.info(`- Item number: ${data.item.number || 'Not found'}`);
                core.info(`- Item type: ${data.item.type || 'Not found'}`);
                core.info(`- Node ID: ${data.item.node_id || 'Not found'}`);
              }
              
              if (!data.item?.node_id) {
                // Try to fetch node_id directly as fallback
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                const number = data.item?.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
                const isPR = data.item?.type === 'pull_request' || '${{ needs.classify.outputs.item_type }}' === 'pull_request';
                
                if (number) {
                  core.info(`🔄 Attempting to fetch node_id for ${isPR ? 'PR' : 'Issue'} #${number} as fallback...`);
                  
                  try {
                    if (isPR) {
                      const pr = await github.rest.pulls.get({owner, repo, pull_number: number});
                      data.item.node_id = pr.data.node_id;
                    } else {
                      const issue = await github.rest.issues.get({owner, repo, issue_number: number});
                      data.item.node_id = issue.data.node_id;
                    }
                    
                    if (data.item.node_id) {
                      core.info(`✅ Successfully retrieved node_id: ${data.item.node_id}`);
                      fs.writeFileSync('classification.json', JSON.stringify(data, null, 2));
                    }
                  } catch (e) {
                    core.warning(`❌ Failed to fetch node_id: ${e.message}`);
                  }
                }
              }
              
              // Log classifications to make them more visible
              if (data.classifications) {
                core.info('\n📋 Classification Results:');
                
                if (data.classifications.areas) {
                  core.info('Areas:');
                  data.classifications.areas.forEach(area => {
                    core.info(`- ${area.value}: ${area.confidence * 100}% confidence`);
                    core.info(`  Reason: ${area.reason}`);
                  });
                }
                
                if (data.classifications.risk) {
                  core.info(`Risk: ${data.classifications.risk.value} (${data.classifications.risk.confidence * 100}% confidence)`);
                  core.info(`Reason: ${data.classifications.risk.reason}`);
                }
                
                if (data.classifications.phase) {
                  core.info(`Phase: ${data.classifications.phase.value}`);
                }
                
                if (data.classifications.priority) {
                  core.info(`Priority: ${data.classifications.priority.value}`);
                }
              }
              
            } catch (e) {
              core.error(`❌ Failed to parse classification.json: ${e.message}`);
            }

      - name: Add to Project with Classification
        uses: actions/github-script@v7
        env:
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
          PROJECT_TITLE: ${{ github.event.inputs.project_title || env.DEFAULT_PROJECT_TITLE }}
          NODE_ID_FALLBACK: ${{ needs.classify.outputs.node_id }}
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const isDryRun = !process.env.GH_PROJECT_TOKEN || '${{ github.event.inputs.dry_run }}' === 'true';
            const projectTitle = process.env.PROJECT_TITLE || 'MerajutASA Program Board';
            const nodeIdFallback = process.env.NODE_ID_FALLBACK;
            
            // Load classification data
            let classification;
            try {
              classification = JSON.parse(fs.readFileSync('classification.json', 'utf8'));
              core.info('✅ Loaded classification data');
            } catch (e) {
              core.setFailed(`Failed to load classification data: ${e.message}`);
              return;
            }
            
            // Extract key information
            const item = classification.item || {};
            const classifications = classification.classifications || {};
            const labels = classification.labels?.final || [];
            
            const itemType = item.type || '${{ needs.classify.outputs.item_type }}';
            const itemNumber = item.number || parseInt('${{ needs.classify.outputs.item_number }}', 10);
            const isPR = itemType === 'pull_request';
            
            // Get node_id from classification data or fallback
            let contentId = item.node_id || nodeIdFallback;
            
            // If still no node_id, fetch it directly
            if (!contentId) {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              try {
                core.info(`🔄 No node_id found in data, fetching directly for ${isPR ? 'PR' : 'Issue'} #${itemNumber}...`);
                
                if (isPR) {
                  const pr = await github.rest.pulls.get({owner, repo, pull_number: itemNumber});
                  contentId = pr.data.node_id;
                } else {
                  const issue = await github.rest.issues.get({owner, repo, issue_number: itemNumber});
                  contentId = issue.data.node_id;
                }
                
                if (contentId) {
                  core.info(`✅ Successfully retrieved node_id: ${contentId}`);
                }
              } catch (e) {
                core.setFailed(`Failed to fetch node_id: ${e.message}`);
                return;
              }
            }
            
            if (!contentId) {
              core.setFailed('Missing node_id. Cannot add to project.');
              return;
            }
            
            // Project configuration
            const ownerLogin = context.repo.owner;
            
            core.info(`🎯 Processing ${isPR ? 'PR' : 'Issue'} #${itemNumber} for project "${projectTitle}"`);
            core.info(`Using node ID: ${contentId}`);
            
            if (isDryRun) {
              core.info('🧪 DRY RUN MODE: Will simulate but not make actual changes');
              // Write summary for dry run
              fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                timestamp: new Date().toISOString(),
                dry_run: true,
                project: projectTitle,
                item: {
                  type: itemType,
                  number: itemNumber,
                  title: item.title,
                  node_id: contentId,
                  classifications: classifications
                }
              }, null, 2));
              return;
            }
            
            // Project lookup
            const projectQuery = `
              query($owner: String!) {
                repositoryOwner(login: $owner) {
                  id
                  login
                  ... on User {
                    projectsV2(first: 20) {
                      nodes {
                        id title url public
                        fields(first: 50) {
                          nodes {
                            __typename
                            ... on ProjectV2FieldCommon { id name dataType }
                            ... on ProjectV2SingleSelectField { 
                              id name dataType 
                              options { id name color description } 
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            try {
              const resp = await github.graphql(projectQuery, { owner: ownerLogin });
              const nodes = resp.repositoryOwner?.projectsV2?.nodes || [];
              
              const project = nodes.find(p => p.title === projectTitle)
                    || nodes.find(p => p.title.toLowerCase() === projectTitle.toLowerCase())
                    || nodes.find(p => p.title === 'MerajutASA Program Board');
                    
              if (!project) {
                core.warning(`❌ Project "${projectTitle}" not found in ${ownerLogin}'s account`);
                core.info('💡 Available projects:');
                for (const p of nodes) {
                  core.info(`- ${p.title}`);
                }
                return;
              }
              
              core.info(`✅ Using project: ${project.title} (${project.url || 'N/A'})`);
              
              // The rest of the project integration logic follows
              const projectId = project.id;
              
              // Check if already in project
              const itemQuery = `
                query($projectId: ID!, $first: Int = 100) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: $first) {
                        nodes {
                          id
                          content {
                            ... on Issue { id number repository { nameWithOwner } }
                            ... on PullRequest { id number repository { nameWithOwner } }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const itemsResp = await github.graphql(itemQuery, { projectId });
              const items = itemsResp.node.items.nodes;
              
              const repoFullName = `${context.repo.owner}/${context.repo.repo}`;
              const existingItem = items.find(i => 
                i.content && 
                i.content.number === itemNumber && 
                i.content.repository?.nameWithOwner === repoFullName
              );
              
              let itemId;
              if (existingItem) {
                itemId = existingItem.id;
                core.info(`🔄 Item already exists in project, ID: ${itemId}`);
              } else {
                // Add item to project
                core.info(`➕ Adding ${isPR ? 'PR' : 'Issue'} #${itemNumber} to project`);
                
                try {
                  const addMutation = `
                    mutation($projectId: ID!, $contentId: ID!) { 
                      addProjectV2ItemById(input: {
                        projectId: $projectId, 
                        contentId: $contentId
                      }) { 
                        item { id } 
                      } 
                    }
                  `;
                  
                  core.info(`Using contentId: ${contentId}`);
                  
                  const addResult = await github.graphql(addMutation, { 
                    projectId, 
                    contentId 
                  });
                  
                  itemId = addResult.addProjectV2ItemById.item.id;
                  core.info(`✅ Added item with ID: ${itemId}`);
                  
                  // Write a summary 
                  fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                    timestamp: new Date().toISOString(),
                    project: project.title,
                    item: {
                      type: itemType,
                      number: itemNumber,
                      added_to_project: true,
                    },
                    classifications: classifications
                  }, null, 2));
                  
                } catch (e) {
                  core.setFailed(`Failed to add item to project: ${e.message}`);
                  fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                    timestamp: new Date().toISOString(),
                    project: project.title,
                    error: e.message,
                    item: {
                      type: itemType,
                      number: itemNumber,
                      added_to_project: false,
                    }
                  }, null, 2));
                }
              }
            } catch (error) {
              core.setFailed(`Project lookup failed: ${error.message}`);
              fs.writeFileSync('project-integration-summary.json', JSON.stringify({
                timestamp: new Date().toISOString(),
                error: error.message
              }, null, 2));
            }

      - name: Upload Integration Summary
        uses: actions/upload-artifact@v4
        with:
          name: project-integration-summary
          path: project-integration-summary.json
          retention-days: 7
          if-no-files-found: ignore