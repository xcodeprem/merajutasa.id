name: MerajutASA Issue & PR Classification System

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number to process'
        required: false
      dry_run:
        description: 'Dry run mode (no changes)'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: write

env:
  WORKFLOW_VERSION: "2.1.0"
  CREATED_AT: "2025-08-20 06:14:10"
  CREATED_BY: "Andhika-Rey"

jobs:
  classify:
    name: "ðŸ§  Smart Classification"
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ steps.create_artifact.outputs.artifact_name }}
      item_number: ${{ steps.detect.outputs.number }}
      item_type: ${{ steps.detect.outputs.type }}
      node_id: ${{ steps.detect.outputs.node_id }}

    steps:
      - name: Determine item context
        id: detect
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const isPR = !!context.payload.pull_request;
            let number = core.getInput('number');
            if (!number) number = isPR ? context.payload.pull_request.number : (context.payload.issue?.number || null);
            if (!number) { core.setOutput('number',''); return; }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (isPR) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              core.setOutput('type', 'pull_request');
              core.setOutput('number', String(number));
              core.setOutput('node_id', pr.node_id);
            } else {
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: number });
              core.setOutput('type', 'issue');
              core.setOutput('number', String(number));
              core.setOutput('node_id', issue.node_id);
            }

      - name: Classify and annotate
        id: classify
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = Number('${{ steps.detect.outputs.number }}');
            if (!number) { core.info('No item number; skipping'); return null; }

            const isPR = !!context.payload.pull_request;
            let itemData, files = [], allLabels = [], allText = '';

            if (isPR) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const { data: prFiles } = await github.rest.pulls.listFiles({ owner, repo, pull_number: number, per_page: 100 });
              const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 100 });
              const { data: reviewComments } = await github.rest.pulls.listReviewComments({ owner, repo, pull_number: number, per_page: 100 });
              itemData = { ...pr, comments, reviewComments, files: prFiles };
              files = prFiles.map(f => f.filename);
              allLabels = pr.labels.map(l => typeof l === 'string' ? l : l.name);
              allText = [pr.title, pr.body, ...comments.map(c => c.body), ...reviewComments.map(c => c.body)]
                .filter(Boolean).join('\n').toLowerCase();
            } else {
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: number });
              const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 100 });
              itemData = { ...issue, comments };
              allLabels = issue.labels.map(l => typeof l === 'string' ? l : l.name);
              allText = [issue.title, issue.body, ...comments.map(c => c.body)].filter(Boolean).join('\n').toLowerCase();
            }

            function topOne(arr, fallback) { return (arr && arr[0]) ? arr[0] : fallback; }

            function detectArea(text, files, item) {
              const map = { security:["security","auth","oauth","jwt"], 'api-gateway':["api","gateway","endpoint"], monitoring:["monitor","log","metric","alert"], performance:["performance","latency","optimize"], docs:["docs","documentation","readme"], infrastructure:["docker","kubernetes","deploy","ci"], compliance:["compliance","audit","policy"], ui:["ui","frontend","css","html"], data:["data","database","sql","mongo"] };
              const scores = Object.fromEntries(Object.keys(map).map(k=>[k,0]));
              for (const [k, kws] of Object.entries(map)) for (const kw of kws) scores[k]+= (text.match(new RegExp(`\\b${kw}\\b`,'gi'))||[]).length;
              for (const f of files||[]) {
                const s=f.toLowerCase(); if(/auth|login|password/.test(s)) scores.security+=2; if(/api|route|controller/.test(s)) scores['api-gateway']+=2; if(/monitor|log|metric/.test(s)) scores.monitoring+=2; if(/perf|optimize|cache/.test(s)) scores.performance+=2; if(/docs|\.md$/.test(s)) scores.docs+=2; if(/docker|k8s|deploy/.test(s)) scores.infrastructure+=2; if(/compliance|audit/.test(s)) scores.compliance+=2; if(/ui|css|html|components/.test(s)) scores.ui+=2; if(/db|sql|mongo|data\//.test(s)) scores.data+=2; }
              const ranked = Object.entries(scores).sort((a,b)=>b[1]-a[1]).filter(([,v])=>v>0).slice(0,2);
              if (!ranked.length) return [{id:'api-gateway',confidence:0.5,evidence:'default'}];
              return ranked.map(([id,score])=>({id,confidence:Math.min(0.95,0.5+score/10),evidence:`score ${score}`}));
            }
            function detectRisk(text){ if(/critical|urgent|breach|crash|data loss/.test(text)) return [{id:'high',confidence:0.9,evidence:'keywords'}]; if(/refactor|significant|integration/.test(text)) return [{id:'medium',confidence:0.8,evidence:'keywords'}]; return [{id:'low',confidence:0.7,evidence:'default'}]; }
            function detectPriority(text){ if(/\bp0\b|urgent|critical/.test(text)) return [{id:'p0',confidence:0.9,evidence:'explicit'}]; if(/\bp1\b|high priority/.test(text)) return [{id:'p1',confidence:0.9,evidence:'explicit'}]; if(/\bp3\b|low priority/.test(text)) return [{id:'p3',confidence:0.9,evidence:'explicit'}]; return [{id:'p2',confidence:0.7,evidence:'default'}]; }
            function detectStatus(text,item,isPR){ if(isPR){ if(item.merged||item.state==='closed') return [{id:'done',confidence:1,evidence:'state'}]; if(item.draft) return [{id:'in-progress',confidence:0.9,evidence:'draft'}]; return [{id:'in-review',confidence:0.9,evidence:'open'}]; } if(item.state==='closed') return [{id:'done',confidence:1,evidence:'closed'}]; if(/in progress|blocked|waiting/.test(text)) return [{id: /blocked|waiting/.test(text)?'blocked':'in-progress',confidence:0.85,evidence:'explicit'}]; return [{id:'todo',confidence:0.7,evidence:'default'}]; }
            function detectSize(text,files,item,isPR){ if(isPR){ const total=(item.files||[]).reduce((s,f)=>s+(f.additions||0)+(f.deletions||0),0); if(total<10) return [{id:'xs',confidence:0.9,evidence:`${total} lines`}]; if(total<100) return [{id:'small',confidence:0.9,evidence:`${total} lines`}]; if(total<300) return [{id:'medium',confidence:0.9,evidence:`${total} lines`}]; if(total<1000) return [{id:'large',confidence:0.9,evidence:`${total} lines`}]; return [{id:'xl',confidence:0.9,evidence:`${total} lines`}]; } const len=(item.body||'').length; if(len>1000) return [{id:'large',confidence:0.7,evidence:`${len} chars`}]; if(len>500) return [{id:'medium',confidence:0.7,evidence:`${len} chars`}]; if(len>200) return [{id:'small',confidence:0.7,evidence:`${len} chars`}]; return [{id:'xs',confidence:0.7,evidence:`${len} chars`}]; }
            function detectPhase(text){ const m=/phase\s*(\d+)/i.exec(text); return [{id:(m?m[1]:'2'),confidence:m?0.9:0.6,evidence:m?`explicit phase ${m[1]}`:'default'}]; }
            function detectTeam(text,files,areas){ const map={security:'security','api-gateway':'backend-dev',monitoring:'qa',performance:'backend-dev',docs:'docs',infrastructure:'devops',compliance:'security',ui:'frontend',data:'backend-dev'}; const id=areas?.[0]?.id; return [{id:(map[id]||'backend-dev'),confidence:0.75,evidence:id?`from area ${id}`:'default'}]; }
            function detectHealth(text,files,item,isPR){ if(isPR){ let s=50; const hasTests=(files||[]).some(f=>/test|spec|__tests__/i.test(f)); const hasDocs=(files||[]).some(f=>/docs\/|\.md$/i.test(f)); if(hasTests) s+=20; if(hasDocs) s+=15; if((files||[]).length>20) s-=10; s=Math.max(10,Math.min(100,s)); if(s>=90) return [{id:'90-99',confidence:0.8,evidence:`${s}`}]; if(s>=75) return [{id:'75-89',confidence:0.8,evidence:`${s}`}]; if(s>=50) return [{id:'50-74',confidence:0.8,evidence:`${s}`}]; if(s>=25) return [{id:'25-49',confidence:0.8,evidence:`${s}`}]; return [{id:'0-24',confidence:0.8,evidence:`${s}`}]; } let s=50; if((item.body||'').length>100) s+=10; if(item.assignees?.length) s+=5; if(item.comments?.length) s+=5; if(!item.body||item.body.length<20) s-=15; s=Math.max(10,Math.min(100,s)); if(s>=90) return [{id:'90-99',confidence:0.8,evidence:`${s}`}]; if(s>=75) return [{id:'75-89',confidence:0.8,evidence:`${s}`}]; if(s>=50) return [{id:'50-74',confidence:0.8,evidence:`${s}`}]; if(s>=25) return [{id:'25-49',confidence:0.8,evidence:`${s}`}]; return [{id:'0-24',confidence:0.8,evidence:`${s}`}]; }

            const areas = detectArea(allText, files, itemData);
            const classifications = {
              areas,
              risk: detectRisk(allText, files, itemData),
              priority: detectPriority(allText, files, itemData),
              status: detectStatus(allText, itemData, isPR),
              size: detectSize(allText, files, itemData, isPR),
              phase: detectPhase(allText),
              team: detectTeam(allText, files, areas),
              health: detectHealth(allText, files, itemData, isPR)
            };

            const newLabels = [];
            for (const a of classifications.areas) newLabels.push(`area:${a.id}`);
            newLabels.push(`risk:${topOne(classifications.risk,{id:'low'}).id}`);
            newLabels.push(`status:${topOne(classifications.status,{id:'todo'}).id}`);
            newLabels.push(`size:${topOne(classifications.size,{id:'small'}).id}`);
            newLabels.push(`priority:${topOne(classifications.priority,{id:'p2'}).id}`);
            newLabels.push(`phase:${topOne(classifications.phase,{id:'2'}).id}`);
            newLabels.push(`team:${topOne(classifications.team,{id:'backend-dev'}).id}`);
            newLabels.push(`health:${topOne(classifications.health,{id:'50-74'}).id}`);

            const existing = new Set(allLabels);
            const toAdd = newLabels.filter(l=>!existing.has(l));
            const toRemove = allLabels.filter(l => /^(area|risk|status|size|priority|phase|team|health):/.test(l) && !newLabels.includes(l));

            try {
              for (const l of toRemove) await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: l });
              if (toAdd.length) await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: toAdd });
            } catch (e) { core.warning(`Label update failed: ${e.message}`); }

            const lines = [];
            lines.push('## ðŸ§  MerajutASA Classification Summary');
            lines.push('');
            lines.push(`Areas: ${classifications.areas.map(a=>a.id).join(', ')}`);
            lines.push(`Risk: ${classifications.risk[0].id}`);
            lines.push(`Priority: ${classifications.priority[0].id}`);
            lines.push(`Status: ${classifications.status[0].id}`);
            lines.push(`Size: ${classifications.size[0].id}`);
            lines.push(`Phase: ${classifications.phase[0].id}`);
            lines.push(`Team: ${classifications.team[0].id}`);
            lines.push(`Health: ${classifications.health[0].id}`);
            try { await github.rest.issues.createComment({ owner, repo, issue_number: number, body: lines.join('\n') }); } catch {}

            return {
              schema_version: process.env.WORKFLOW_VERSION,
              item: {
                number,
                type: isPR ? 'pull_request' : 'issue',
                title: itemData.title,
                created_at: itemData.created_at,
                updated_at: itemData.updated_at,
                url: itemData.html_url,
                author: itemData.user?.login,
                node_id: itemData.node_id
              },
              classifications
            };

      - name: Create Classification Artifact
        id: create_artifact
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            const artifactName = `classification-${context.runId}`;
            const classificationResult = ${{ toJSON(steps.classify.outputs.result) }};
            const artifactData = {
              metadata: {
                timestamp: new Date().toISOString(),
                workflow_version: process.env.WORKFLOW_VERSION,
                created_at: process.env.CREATED_AT,
                created_by: process.env.CREATED_BY,
                run_id: context.runId,
                run_number: context.runNumber,
                repository: `${context.repo.owner}/${context.repo.repo}`,
                actor: context.actor,
                event: context.eventName,
                ref: context.ref
              },
              classification: classificationResult
            };
            fs.writeFileSync('classification.json', JSON.stringify(artifactData, null, 2));
            core.setOutput('artifact_name', artifactName);
            return artifactName;

      - name: Upload Classification Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_artifact.outputs.artifact_name }}
          path: classification.json
          retention-days: 7

  project_integration:
    name: "ðŸ“‹ Project Board Integration"
    needs: classify
    if: needs.classify.outputs.item_number
    runs-on: ubuntu-latest
    steps:
      - name: Download Classification
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.classify.outputs.artifact_name }}

      - name: Update Project Board (User Project)
        uses: actions/github-script@v7
        env:
          PROJECT_TITLE: "MerajutASA Program Board"
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            const data = JSON.parse(fs.readFileSync('classification.json','utf8'));
            const classification = data.classification;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            if (!classification?.item?.node_id) { core.info('No node_id; skipping'); return; }
            if (dryRun) { core.info('DRY RUN: skip project update'); return; }

            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_TITLE;

            const projQuery = `
              query($owner:String!){
                user(login:$owner){
                  projectsV2(first:50){ nodes{ id title url fields(first:100){ nodes{ ... on ProjectV2SingleSelectField { id name options{ id name } } } } } }
                }
              }
            `;
            const projRes = await github.graphql(projQuery, { owner });
            const projects = projRes.user?.projectsV2?.nodes || [];
            const project = projects.find(p=>p.title===projectTitle);
            if (!project) { core.warning(`Project ${projectTitle} not found`); return; }

            const contentId = classification.item.node_id;
            let itemId = null;
            try {
              const addMutation = `mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId,contentId:$contentId}){ item{ id } } }`;
              const addRes = await github.graphql(addMutation, { projectId: project.id, contentId });
              itemId = addRes?.addProjectV2ItemById?.item?.id || null;
            } catch (e) { core.info(`add item ignored: ${e.message}`); }

            if (!itemId) {
              let after = null;
              const itemQuery = `query($projectId:ID!,$after:String){ node(id:$projectId){ ... on ProjectV2 { items(first:50,after:$after){ nodes{ id content{ __typename ... on Issue{ id } ... on PullRequest{ id } } } pageInfo{ hasNextPage endCursor } } } }}`;
              while (true) {
                const r = await github.graphql(itemQuery, { projectId: project.id, after });
                const nodes = r?.node?.items?.nodes || [];
                const m = nodes.find(n=>n?.content?.id===contentId);
                if (m) { itemId = m.id; break; }
                const p = r?.node?.items?.pageInfo; if (!p?.hasNextPage) break; after = p.endCursor;
              }
            }
            if (!itemId) { core.warning('No project item id'); return; }

            function fieldByName(name){ return project.fields.nodes.find(f=>f.name===name); }
            async function setSingle(name, optLabel){ const f=fieldByName(name); if(!f||!f.options) return; const o=f.options.find(x=>x.name.toLowerCase()===(String(optLabel).toLowerCase())); if(!o) return; const m=`mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$opt:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId,itemId:$itemId,fieldId:$fieldId,value:{ singleSelectOptionId:$opt }}){ projectV2Item{ id } } }`; await github.graphql(m,{ projectId: project.id, itemId, fieldId: f.id, opt: o.id }); core.info(`Set ${name}=${o.name}`); }

            const cls = classification.classifications;
            const map = {
              AREA: { security:'Security','api-gateway':'API Gateway & Services', monitoring:'Monitoring & Observability', performance:'Performance Optimization', docs:'Documentation', infrastructure:'Infrastructure', compliance:'Compliance', ui:'UI Components', data:'Data Management' },
              RISK: { high:'High', medium:'Medium', low:'Low' },
              PRIORITY: { p0:'P0', p1:'P1', p2:'P2', p3:'P3' },
              STATUS: { 'todo':'Todo','in-progress':'In Progress','in-review':'In Review', blocked:'Blocked', done:'Done' },
              SIZE: { xs:'XS', small:'Small', medium:'Medium', large:'Large', xl:'XL' },
              PHASE: { '1':'Phase 1','2-week-1':'Phase 2 W1','2-week-2':'Phase 2 W2','2-week-3':'Phase 2 W3','2-week-4':'Phase 2 W4','2-week-5':'Phase 2 W5','2-week-6':'Phase 2 W6','3-q1':'Phase 3 Q1','3-q2':'Phase 3 Q2','3-q3':'Phase 3 Q3','3-q4':'Phase 3 Q4' },
              TEAM: { 'backend-dev':'Backend Dev', frontend:'Frontend', devops:'DevOps', security:'Security', qa:'QA', docs:'Documentation', design:'Design' },
              HEALTH: { '100':'100/100','90-99':'90-99/100','75-89':'75-89/100','50-74':'50-74/100','25-49':'25-49/100','0-24':'0-24/100' }
            };
            const first = (arr)=>arr && arr[0];
            const area = first(cls.areas)?.id; if (area && map.AREA[area]) await setSingle('Area', map.AREA[area]);
            const risk = first(cls.risk)?.id; if (risk && map.RISK[risk]) await setSingle('Risk', map.RISK[risk]);
            const pri = first(cls.priority)?.id; if (pri && map.PRIORITY[pri]) await setSingle('Priority', map.PRIORITY[pri]);
            const st = first(cls.status)?.id; if (st && map.STATUS[st]) await setSingle('Status', map.STATUS[st]);
            const sz = first(cls.size)?.id; if (sz && map.SIZE[sz]) await setSingle('Size', map.SIZE[sz]);
            const ph = first(cls.phase)?.id; if (ph && (map.PHASE[ph]||`Phase ${ph}`)) await setSingle('Phase', map.PHASE[ph]||`Phase ${ph}`);
            const tm = first(cls.team)?.id; if (tm && map.TEAM[tm]) await setSingle('Team Assignment', map.TEAM[tm]);
            const he = first(cls.health)?.id; if (he && map.HEALTH[he]) await setSingle('Health Score', map.HEALTH[he]);

      - name: Optional cross-workflow sync (labels -> board)
        if: always()
        uses: actions/github-script@v7
        env:
          CROSS_SYNC_WORKFLOW: ''
        with:
          github-token: ${{ github.token }}
          script: |
            const wf = process.env.CROSS_SYNC_WORKFLOW || '';
            if (!wf) { core.info('Cross-sync workflow not set; skipping'); return; }
            const fs = require('fs');
            let number = null;
            try { const artifactData = JSON.parse(fs.readFileSync('classification.json', 'utf8')); number = artifactData?.classification?.item?.number; } catch {}
            if (!number) { core.info('No number found for cross-sync'); return; }
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: wf,
                ref: context.ref || context.sha,
                inputs: { numbers: String(number) }
              });
              core.info(`Triggered cross workflow sync for #${number}`);
            } catch (e) { core.warning(`Failed to trigger cross workflow sync: ${e.message}`); }