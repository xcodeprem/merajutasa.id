name: Setup Project V2

on:
  workflow_dispatch:
    inputs:
      owner:
        description: 'User/Org owner (contoh: Andhika-Rey)'
        required: true
        default: 'Andhika-Rey'
      project_title:
        description: 'Judul Project'
        required: true
        default: 'MerajutASA Program Board'
      public:
        description: 'Public? (true/false)'
        required: true
        default: 'false'

jobs:
  create-project:
    runs-on: ubuntu-latest
    steps:
      - name: Create Project V2 and fields
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }} # Classic PAT (repo, project)
        with:
          github-token: ${{ secrets.GH_PROJECT_TOKEN }}
          # Alternatif (tidak disarankan untuk akun personal):
          # permissions di job + github-token: ${{ github.token }}
          script: |
            const ownerLogin = '${{ inputs.owner }}';
            const title = '${{ inputs.project_title }}';
            const isPublic = '${{ inputs.public }}' === 'true';

            // 1) Resolve owner (User/Org)
            let ownerId, existingProjects = [];
            try {
              const ownerResp = await github.graphql(`
                query($login: String!) {
                  repositoryOwner(login: $login) {
                    id
                    ... on User { projectsV2(first: 50) { nodes { id title url public } } }
                    ... on Organization { projectsV2(first: 50) { nodes { id title url public } } }
                  }
                }
              `, { login: ownerLogin });
              ownerId = ownerResp.repositoryOwner?.id;
              existingProjects = ownerResp.repositoryOwner?.projectsV2?.nodes || [];
            } catch (error) {
              core.setFailed(`Owner not found: ${ownerLogin} (${error.message})`);
              return;
            }
            if (!ownerId) { core.setFailed(`Owner not found: ${ownerLogin}`); return; }

            // 2) Idempotent project create
            let project = existingProjects.find(p => p.title === title);
            if (!project) {
              const createResp = await github.graphql(`
                mutation($ownerId: ID!, $title: String!) {
                  createProjectV2(input: { ownerId: $ownerId, title: $title }) {
                    projectV2 { id number title url public }
                  }
                }
              `, { ownerId, title });
              project = createResp.createProjectV2.projectV2;
              console.log('Project created:', project.url);
            } else {
              console.log('Project exists:', project.url);
            }

            // 3) Update visibility (best-effort)
            try {
              if (typeof project.public === 'boolean' && project.public !== isPublic) {
                await github.graphql(`
                  mutation($projectId: ID!, $public: Boolean!) {
                    updateProjectV2(input: { projectId: $projectId, public: $public }) {
                      projectV2 { id public }
                    }
                  }
                `, { projectId: project.id, public: isPublic });
              }
            } catch (e) {
              core.warning('Skipping visibility update: ' + (e?.message || e));
            }

            // 4) Fetch fields
            const fieldsResp = await github.graphql(`
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 50) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon { id name dataType }
                        ... on ProjectV2SingleSelectField { id name options { id name } }
                      }
                    }
                  }
                }
              }
            `, { projectId: project.id });
            const existingFields = fieldsResp.node?.fields?.nodes || [];
            const fieldMapping = {};
            for (const f of existingFields) if (f?.name && f?.id) fieldMapping[f.name] = f.id;

            // Helpers to build SINGLE_SELECT options
            const opt = (name, color, description) => ({ name, color, description });
            const gqlOptions = (arr) => arr.map(o => `{name:"${o.name}", color:${o.color}, description:"${o.description}"}`).join(',');

            async function createSingleSelect(name, optionsArr) {
              if (fieldMapping[name]) { console.log(`Field "${name}" exists, skipping`); return; }
              const m = `
                mutation($projectId: ID!) {
                  createProjectV2Field(input:{
                    projectId:$projectId,
                    dataType:SINGLE_SELECT,
                    name:"${name}",
                    singleSelectOptions:[${gqlOptions(optionsArr)}]
                  }) {
                    projectV2Field { ... on ProjectV2FieldCommon { id name } }
                  }
                }
              `;
              const r = await github.graphql(m, { projectId: project.id });
              fieldMapping[name] = r.createProjectV2Field.projectV2Field.id;
              console.log(`Created field "${name}"`);
            }

            async function ensureSingleSelectOptions(name, optionsArr){
              // If field exists and is SINGLE_SELECT, add any missing options
              const fieldsResp2 = await github.graphql(`
                query($projectId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      fields(first: 50) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField { id name options { id name color description } }
                        }
                      }
                    }
                  }
                }
              `, { projectId: project.id });
              const nodes = fieldsResp2.node?.fields?.nodes || [];
              const f = nodes.find(n => n?.name === name && n.__typename === 'ProjectV2SingleSelectField');
              if (!f) return;
              const existingNames = new Set((f.options||[]).map(o=>o.name));
              const missing = optionsArr.filter(o => !existingNames.has(o.name));
              if (!missing.length) return;
              try {
                const all = [...(f.options||[]).map(o=>({ id:o.id, name:o.name, color:o.color, description:o.description })), ...missing];
                const m = `
                  mutation($projectId: ID!, $fieldId: ID!, $opts: [ProjectV2SingleSelectFieldOptionInput!]!) {
                    updateProjectV2Field(input:{ projectId:$projectId, fieldId:$fieldId, singleSelectOptions:$opts }) { projectV2Field { ... on ProjectV2FieldCommon { id name } } }
                  }
                `;
                await github.graphql(m, { projectId: project.id, fieldId: f.id, opts: all });
                console.log(`Updated options for field "${name}": added ${missing.map(m=>m.name).join(', ')}`);
              } catch (e) {
                core.warning(`Could not update options for '${name}': ${e?.message || e}`);
              }
            }

            async function createTyped(name, dataType) {
              if (fieldMapping[name]) { console.log(`Field "${name}" exists, skipping`); return; }
              const m = `
                mutation($projectId: ID!) {
                  createProjectV2Field(input:{ projectId:$projectId, dataType:${dataType}, name:"${name}" }) {
                    projectV2Field { ... on ProjectV2FieldCommon { id name } }
                  }
                }
              `;
              const r = await github.graphql(m, { projectId: project.id });
              fieldMapping[name] = r.createProjectV2Field.projectV2Field.id;
              console.log(`Created field "${name}"`);
            }

            // 5) Create fields
            await createSingleSelect('Priority', [
              opt('P0','RED','Urgent'),
              opt('P1','ORANGE','High'),
              opt('P2','YELLOW','Medium'),
              opt('P3','GREEN','Planned/Low')
            ]);

            await createSingleSelect('Area', [
              opt('Infrastructure','GRAY','Infra & platform'),
              opt('Security','PURPLE','Security domain'),
              opt('Compliance','BLUE','Compliance & governance'),
              opt('Observability','BLUE','Monitoring & observability'),
              opt('Performance','GREEN','Performance optimization'),
              opt('High Availability','GRAY','HA & resilience'),
              opt('API Gateway','BLUE','Gateway & service mesh'),
              opt('Equity UI','YELLOW','UI modernization'),
              opt('Docs','GRAY','Documentation'),
              opt('CI/CD','ORANGE','Pipelines & automation'),
              opt('Configuration','GRAY','Configs & env'),
              opt('Logging','PURPLE','Unified logging'),
              opt('Error Handling','ORANGE','Error handling'),
              opt('Testing','YELLOW','Testing & QA'),
              opt('Backup','GRAY','Backup & recovery'),
              opt('Load Testing','YELLOW','Load testing'),
              opt('Security Audit','PURPLE','Security audits'),
              opt('Data Pipeline','BLUE','Data pipelines'),
              opt('Mobile API','BLUE','Mobile endpoints'),
              opt('Integration','GRAY','Cross-component integration')
            ]);

            // Ensure critical options exist even on existing boards
            await ensureSingleSelectOptions('Area', [ opt('Infrastructure','GRAY','Infra & platform') ]);

            await createSingleSelect('Phase', [
              opt('Phase 1','GRAY','Foundation'),
              opt('Phase 2 W1','GRAY','Week 1'),
              opt('Phase 2 W2','GRAY','Week 2'),
              opt('Phase 2 W3','GRAY','Week 3'),
              opt('Phase 2 W4','GRAY','Week 4'),
              opt('Phase 2 W5','GRAY','Week 5'),
              opt('Phase 2 W6','GRAY','Week 6'),
              opt('Phase 2 W7','GRAY','Week 7'),
              opt('Phase 2 W8','GRAY','Week 8'),
              opt('Phase 3 Q1','GRAY','Quarter 1'),
              opt('Phase 3 Q2','GRAY','Quarter 2'),
              opt('Phase 3 Q3','GRAY','Quarter 3'),
              opt('Phase 3 Q4','GRAY','Quarter 4')
            ]);

            await createSingleSelect('Risk', [
              opt('Low','GREEN','Low risk'),
              opt('Medium','YELLOW','Medium risk'),
              opt('High','RED','High risk')
            ]);

            await createSingleSelect('Status', [
              opt('To Do','GRAY','To do'),
              opt('In Progress','BLUE','In progress'),
              opt('In Review','YELLOW','In review'),
              opt('Blocked','RED','Blocked'),
              opt('Done','GREEN','Done')
            ]);

            await createTyped('Start date', 'DATE');
            await createTyped('Target date', 'DATE');
            await createTyped('Estimate (h)', 'NUMBER');
            await createTyped('Owner (text)', 'TEXT');
            await createTyped('Links', 'TEXT');
            await createTyped('Milestone', 'TEXT');

            // 6) Upload artifact mapping (best-effort)
            const fs = await import('fs');
            const path = await import('path');
            const artifactDir = path.join(process.env.GITHUB_WORKSPACE || process.cwd(), 'artifacts');
            try {
              await fs.promises.mkdir(artifactDir, { recursive: true });
              const fieldMappingFile = path.join(artifactDir, 'project-fields.json');
              await fs.promises.writeFile(fieldMappingFile, JSON.stringify({
                project_id: project.id,
                project_url: project.url,
                project_title: project.title,
                field_mappings: fieldMapping,
                generated_at: new Date().toISOString()
              }, null, 2));
              console.log('Field mappings saved to artifacts/project-fields.json');
            } catch (error) {
              core.warning('Could not save field mappings artifact: ' + (error?.message || error));
            }

            // 7) Outputs
            core.setOutput('project_url', project.url);
            core.setOutput('project_id', project.id);
            core.setOutput('field_mappings', JSON.stringify(fieldMapping));
      
      - name: Upload project fields artifact
        uses: actions/upload-artifact@v4
        with:
          name: project-fields
          path: artifacts/project-fields.json
          if-no-files-found: warn