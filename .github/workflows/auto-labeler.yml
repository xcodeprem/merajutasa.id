name: Auto Labeler (Heuristic)

on:
  workflow_dispatch:
    inputs:
      number:
        description: 'Issue/PR number when running manually (optional)'
        required: false
        default: ''
      dry_run:
        description: 'Dry run mode - log actions without changing labels'
        required: false
        default: false
        type: boolean
  issues:
    types: [opened, edited, labeled, unlabeled, reopened]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, closed]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  classify-and-label:
    name: "ðŸ¤– Auto-classify and label"
    runs-on: ubuntu-latest
    steps:
      - name: Analyze and apply labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            // Prevent relabel loops when the actor is the bot itself
            if ((context.eventName === 'issues' && ['labeled','unlabeled'].includes(context.payload.action)) ||
                (context.eventName === 'pull_request' && ['labeled','unlabeled'].includes(context.payload.action))) {
              if (context.actor === 'github-actions[bot]') {
                core.info('Skip to prevent relabel loop (actor is github-actions[bot]).');
                return;
              }
            }

            let isPR = context.eventName === 'pull_request';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const inputs = context.payload && context.payload.inputs ? context.payload.inputs : {};
            const manualNumber = (() => { const v = inputs.number; if (!v) return undefined; const n = parseInt(v, 10); return isNaN(n) ? undefined : n; })();
            let number = undefined;
            if (context.eventName === 'pull_request' && context.payload.pull_request) {
              number = context.payload.pull_request.number;
            } else if ((context.eventName === 'issues' || context.eventName === 'issue_comment') && context.payload.issue) {
              number = context.payload.issue.number;
            } else if (context.eventName === 'workflow_dispatch' && manualNumber) {
              number = manualNumber;
              // Detect whether the number refers to a PR
              try { await github.rest.pulls.get({ owner, repo, pull_number: number }); isPR = true; } catch (e) { isPR = false; }
            }
            if (!number) { core.info('No issue/PR number available in this event; skipping.'); return; }
            const dryRun = (() => {
              const inputs = context.payload && context.payload.inputs;
              if (!inputs) return false;
              const v = inputs.dry_run;
              if (typeof v === 'boolean') return v;
              if (typeof v === 'string') return v.toLowerCase() === 'true';
              return false;
            })();

            // Fetch latest item details
            let title = '', body = '', labels = [], milestoneTitle = '';
            if (isPR) {
              const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
              title = pr.title || '';
              body = pr.body || '';
              labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
              milestoneTitle = pr.milestone?.title || '';
            } else {
              const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
              title = issue.title || '';
              body = issue.body || '';
              labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
              milestoneTitle = issue.milestone?.title || '';
            }

            const existing = new Set(labels);

            // For PRs, gather changed files and stats
            let files = [], additions = 0, deletions = 0, changes = 0;
            if (isPR) {
              const perPage = 100;
              let page = 1;
              while (true) {
                const resp = await github.rest.pulls.listFiles({ owner, repo, pull_number: number, per_page: perPage, page });
                files.push(...resp.data);
                if (resp.data.length < perPage) break;
                page += 1;
              }
              additions = files.reduce((s, f) => s + (f.additions || 0), 0);
              deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
              changes = files.reduce((s, f) => s + (f.changes || 0), 0);
            }

            const text = `${title}\n${body}`.toLowerCase();
            const filePaths = files.map(f => (f.filename || '').toLowerCase());

            // Heuristic classifiers
            const hasAny = (s, arr) => arr.some(k => s.includes(k));
            const pathHasAny = (arr) => filePaths.some(p => arr.some(k => p.includes(k)));

            // Area classification
            let area = null;
            if (pathHasAny(['auth', 'security', 'oauth', 'jwt', 'encryption']) || hasAny(text, ['security', 'auth', 'csrf', 'xss'])) area = 'area:security-layer';
            else if (pathHasAny(['monitor', 'metrics', 'grafana', 'prometheus', 'logging', 'trace']) || hasAny(text, ['observability', 'monitoring', 'logging', 'tracing'])) area = 'area:monitoring-observability';
            else if (pathHasAny(['cache', 'optimization', 'perf', 'cdn', 'compression']) || hasAny(text, ['performance', 'optimiz', 'cache'])) area = 'area:performance-optimization';
            else if (pathHasAny(['k8s', 'kubernetes', 'helm', 'manifests', 'charts', 'docker']) || hasAny(text, ['container orchestration', 'kubernetes', 'helm'])) area = 'area:container-orchestration';
            else if (pathHasAny(['.github/workflows', 'deploy', 'pipeline', 'ci', 'cd']) || hasAny(text, ['ci/cd', 'pipeline', 'deployment'])) area = 'area:cicd-pipeline';
            else if (pathHasAny(['backup', 'migrations', 'db/', 'database', 'storage', 's3']) || hasAny(text, ['data management', 'backup'])) area = 'area:data-management';
            else if (pathHasAny(['api/', 'gateway', 'ingress', 'service', 'routes']) || hasAny(text, ['api gateway', 'service mesh', 'api'])) area = 'area:api-gateway-services';
            else if (!isPR && hasAny(text, ['doc', 'documentation']) || pathHasAny(['docs/'])) area = 'area:docs';

            // Risk classification
            let risk = null;
            const largeChange = changes > 500 || additions + deletions > 800;
            if (hasAny(text, ['breaking change', 'critical', 'security', 'vulnerability', 'hotfix']) || largeChange) risk = 'risk:high';
            else if (hasAny(text, ['refactor', 'migration', 'upgrade']) || (changes > 100)) risk = 'risk:medium';
            else risk = 'risk:low';

            // Status label (for issues/PRs)
            let status = null;
            if (isPR) {
              const prState = context.payload.pull_request.state; // open/closed
              const isDraft = context.payload.pull_request.draft;
              const merged = !!context.payload.pull_request.merged;
              if (merged) status = 'status:done';
              else if (prState === 'closed') status = 'status:done';
              else if (context.payload.action === 'ready_for_review' || !isDraft) status = 'status:in-review';
              else status = 'status:in-progress';
            } else {
              const issueState = context.payload.issue.state; // open/closed
              if (issueState === 'closed') status = 'status:done';
              else if (hasAny(text, ['wip', 'progress'])) status = 'status:in-progress';
              else status = 'status:todo';
            }

            // Team assignment by area
            let team = null;
            if (area === 'area:security-layer') team = 'team:security';
            else if (area === 'area:cicd-pipeline' || area === 'area:container-orchestration') team = 'team:devops';
            else if (area === 'area:monitoring-observability') team = 'team:qa';
            else team = 'team:backend-dev';

            // Implementation size from change set
            let size = null;
            const total = additions + deletions;
            if (total <= 100) size = 'size:small';
            else if (total <= 250) size = 'size:medium';
            else if (total <= 500) size = 'size:large';
            else if (total <= 1000) size = 'size:very-large';
            else if (total <= 2000) size = 'size:enterprise';
            else size = 'size:system';

            // Health score heuristic (basic): tests/docs present increase score
            let health = 'health:50-74';
            const hasTests = pathHasAny(['test', 'spec']);
            const hasDocs = pathHasAny(['docs/', 'readme']);
            const thorough = hasTests && hasDocs && !largeChange;
            if (thorough) health = 'health:90-99';
            else if (hasTests || hasDocs) health = 'health:75-89';
            else if (largeChange) health = 'health:25-49';

            // Iteration from milestone or title/body
            let iteration = null;
            const iterMatch = (milestoneTitle || text).match(/sprint[-\s]?(\d+)/i);
            if (iterMatch) iteration = `iteration:sprint-${iterMatch[1]}`;
            else if (hasAny(text, ['maintenance'])) iteration = 'iteration:maintenance';
            else if (hasAny(text, ['research', 'spike'])) iteration = 'iteration:research';

            // Build label sets (single-choice categories)
            const singleChoiceSets = {
              risk: ['risk:low','risk:medium','risk:high'],
              status: ['status:todo','status:in-progress','status:in-review','status:blocked','status:done'],
              size: ['size:small','size:medium','size:large','size:very-large','size:enterprise','size:system'],
              health: ['health:100','health:90-99','health:75-89','health:50-74','health:25-49','health:0-24'],
              iteration: ['iteration:sprint-1','iteration:sprint-2','iteration:sprint-3','iteration:sprint-4','iteration:sprint-5','iteration:sprint-6','iteration:epic','iteration:maintenance','iteration:research']
            };

            const toAdd = new Set();
            const toRemove = new Set();

            function setSingleChoice(target) {
              if (!target) return;
              for (const [_, set] of Object.entries(singleChoiceSets)) {
                if (set.includes(target)) {
                  set.forEach(l => { if (existing.has(l) && l !== target) toRemove.add(l); });
                }
              }
              if (!existing.has(target)) toAdd.add(target);
            }

            // Apply choices
            setSingleChoice(risk);
            setSingleChoice(status);
            setSingleChoice(size);
            setSingleChoice(health);
            setSingleChoice(iteration);
            if (area && !existing.has(area)) toAdd.add(area);
            if (team && !existing.has(team)) toAdd.add(team);


            const addList = Array.from(toAdd);
            const removeList = Array.from(toRemove);

            // Dry-run log
            if (dryRun) {
              core.info('ðŸ§ª DRY RUN: Label changes preview');
              core.info(`Would add: ${addList.join(', ') || 'None'}`);
              core.info(`Would remove: ${removeList.join(', ') || 'None'}`);
              return;
            }

            // Apply removals first
            for (const l of removeList) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: l });
                core.info(`Removed label: ${l}`);
              } catch (e) {
                if (e.status !== 404) core.warning(`Failed to remove label ${l}: ${e.message}`);
              }
            }

            // Apply additions in chunks
            if (addList.length) {
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: addList });
                core.info(`Added labels: ${addList.join(', ')}`);
              } catch (e) {
                core.warning(`Failed to add labels: ${e.message}`);
              }
            } else {
              core.info('No labels to add');
            }

            // Optional summary output
            core.info('Label classification complete.');

            // Write optional summary file for artifact upload
            try {
              const fs = require('fs');
              const path = require('path');
              const summary = {
                repo: `${owner}/${repo}`,
                number,
                isPR,
                dryRun,
                title,
                milestoneTitle,
                stats: { additions, deletions, changes },
                classifications: { area, risk, status, team, size, health, iteration },
                files: files.map(f => ({ filename: f.filename, additions: f.additions, deletions: f.deletions, changes: f.changes }))
              };
              const outPath = path.join(process.env.GITHUB_WORKSPACE || '.', 'auto-label-summary.json');
              fs.writeFileSync(outPath, JSON.stringify(summary, null, 2), 'utf8');
              core.info(`Wrote summary to ${outPath}`);
            } catch (e) {
              core.warning(`Failed to write summary file: ${e.message}`);
            }

      - name: ðŸ“¦ Upload Auto-label Summary (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: auto-labeler-summary
          path: ${{ github.workspace }}/auto-label-summary.json
          if-no-files-found: ignore
