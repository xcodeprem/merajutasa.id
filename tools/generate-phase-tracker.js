#!/usr/bin/env node
/**
 * generate-phase-tracker.js
 * Cross-platform generator for artifacts/phase-tracker.json reflecting current enforcement phase
 * derived from DEC-20250812-03 schedule or default windows.
 */
import { promises as fs } from 'fs';
import { execFileSync } from 'child_process';

const DEC_FILE = process.env.DEC_FILE || 'docs/governance/dec/DEC-20250812-03-principles-reference-activation.md';
const NOW_OVERRIDE = process.env.NOW;

function toISO(dt){
  if (typeof dt === 'string') return new Date(dt).toISOString();
  return dt.toISOString();
}

async function fileExists(p){
  try { await fs.access(p); return true; } catch { return false; }
}

function addHours(iso, hours){
  const d = new Date(iso);
  d.setUTCHours(d.getUTCHours() + hours);
  return d.toISOString();
}

function parseScheduleFromDec(text){
  const get = (k)=>{
    const m = text.match(new RegExp(`${k}:\\s*([0-9TZ:\\-]+)`));
    return m ? m[1] : null;
  };
  const phase0 = get('phase0_start_utc');
  const phase1 = get('phase1_start_utc');
  const phase2 = get('phase2_start_utc');
  return { phase0, phase1, phase2 };
}

function epoch(iso){ return Math.floor(new Date(iso).getTime()/1000); }

async function main(){
  if(!(await fileExists(DEC_FILE))){
    console.error(`ERROR: DEC file not found: ${DEC_FILE}`);
    process.exit(1);
  }
  const nowIso = NOW_OVERRIDE ? toISO(NOW_OVERRIDE) : new Date().toISOString();
  const decText = await fs.readFile(DEC_FILE, 'utf8');
  let { phase0, phase1, phase2 } = parseScheduleFromDec(decText);

  if(!phase0){
    // derive from git commit timestamp if available (no shell interpolation)
    try {
      const out = execFileSync('git', ['log', '-1', '--format=%cI', '--', DEC_FILE], { stdio:['ignore','pipe','ignore'] })
        .toString()
        .trim();
      if (out) phase0 = out;
    } catch { /* ignore */ }
    if(!phase0){
      console.error('ERROR: Cannot derive commit timestamp for DEC file');
      process.exit(1);
    }
    phase1 = addHours(phase0, 48);
    phase2 = addHours(phase0, 168);
  }

  const nowE = epoch(nowIso); const p1E = epoch(phase1); const p2E = epoch(phase2);
  let current = 'PHASE_0_WARN';
  if (process.env.FORCE_PHASE) {
    const allowed = new Set(['PHASE_0_WARN','PHASE_1_ERROR','PHASE_2_DENY']);
    current = allowed.has(process.env.FORCE_PHASE) ? process.env.FORCE_PHASE : current;
  } else {
    if (nowE >= p1E && nowE < p2E) current = 'PHASE_1_ERROR';
    else if (nowE >= p2E) current = 'PHASE_2_DENY';
  }

  const until = (iso)=> Math.max(0, epoch(iso) - nowE);
  const data = {
    generated_utc: nowIso,
    dec_file: DEC_FILE,
    phase0_start_utc: new Date(phase0).toISOString(),
    phase1_start_utc: new Date(phase1).toISOString(),
    phase2_start_utc: new Date(phase2).toISOString(),
    current_phase: current,
  seconds_until_phase1: current==='PHASE_1_ERROR' || current==='PHASE_2_DENY' ? 0 : until(phase1),
  seconds_until_phase2: current==='PHASE_2_DENY' ? 0 : until(phase2),
    policy: {
      phase0: 'WARN (informational only)',
      phase1: 'ERROR (blocks merges unless override)',
      phase2: 'DENY (strict block)'
    },
    notes: 'Generated by tools/generate-phase-tracker.js (cross-platform)'
  };

  await fs.mkdir('artifacts', { recursive: true });
  await fs.writeFile('artifacts/phase-tracker.json', JSON.stringify(data, null, 2));
  console.log(`[phase-tracker] Generated artifacts/phase-tracker.json (phase=${current})`);
}

main().catch(e=>{ console.error('[phase-tracker] error', e); process.exit(2); });
